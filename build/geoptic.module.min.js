import{ShaderMaterial as e,Vector3 as t,DoubleSide as i,WebGLRenderTarget as s,Mesh as n,BufferAttribute as a,TextureLoader as r,InstancedMesh as o,InstancedBufferAttribute as l,CylinderGeometry as h,Matrix4 as d,Group as c,Euler as m,BufferGeometry as u,IcosahedronGeometry as p,SphereGeometry as g,PlaneGeometry as v,WebGLRenderer as f,PerspectiveCamera as y,Scene as x,Color as b,AmbientLight as C,PointLight as M,Box3 as w}from"https://unpkg.com/three@0.125.1/build/three.module.js";import{TrackballControls as F}from"https://unpkg.com/three@0.125.1/examples/jsm/controls/TrackballControls.js";import{WEBGL as k}from"https://unpkg.com/three@0.125.1/examples/jsm/WebGL.js";import{Reflector as E}from"https://unpkg.com/three@0.125.1/examples/jsm/objects/Reflector.js";import"https://unpkg.com/three@0.125.1/examples/jsm/loaders/RGBELoader.js";import P from"https://unpkg.com/three@0.125.1/examples/jsm/libs/stats.module.js";import{GUI as V}from"https://unpkg.com/dat.gui@0.7.6/build/dat.gui.module.js";let S="\n        uniform sampler2D Matcap_r; // Matcap texture\n        uniform sampler2D Matcap_g; // Matcap texture\n        uniform sampler2D Matcap_b; // Matcap texture\n        uniform sampler2D Matcap_k; // Matcap texture\n",_="\n        float getEdgeFactor(vec3 UVW, vec3 edgeReal, float width) {\n\n            // The Nick Sharp Edge Function (tm). There are many like it, but this one is his.\n            float slopeWidth = 1.;\n\n            vec3 fw = fwidth(UVW);\n            vec3 realUVW = max(UVW, 1. - edgeReal.yzx);\n            vec3 baryWidth = slopeWidth * fw;\n\n            vec3 end = width * fw;\n            vec3 dist = smoothstep(end - baryWidth, end, realUVW);\n\n            float e = 1.0 - min(min(dist.x, dist.y), dist.z);\n            return e;\n        }\n\n        vec4 lightSurfaceMat(vec3 color, vec2 Normal) {\n            vec4 mat_r = sRGBToLinear(texture2D(Matcap_r, Normal));\n            vec4 mat_g = sRGBToLinear(texture2D(Matcap_g, Normal));\n            vec4 mat_b = sRGBToLinear(texture2D(Matcap_b, Normal));\n            vec4 mat_k = sRGBToLinear(texture2D(Matcap_k, Normal));\n\n            vec4 colorCombined = color.r * mat_r + color.g * mat_g + color.b * mat_b +\n                                (1. - color.r - color.g - color.b) * mat_k;\n\n            return LinearTosRGB( colorCombined );\n        }\n";function T(s,n,a,r){let o=`\n        ${S}\n        uniform vec3 edgeColor;\n        uniform float edgeWidth;\n        uniform vec3 color1;\n        uniform vec3 color2;\n        uniform float paramScale;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying vec2 Coord;\n\n        ${_}\n\n        void main(void){\n            float alpha = getEdgeFactor(Barycoord, vec3(1.,1.,1.), edgeWidth);\n\n            // Apply the checkerboard effect\n            float mX = mod(Coord.x, 2.0 * paramScale) / paramScale - 1.f; // in [-1, 1]\n            float mY = mod(Coord.y, 2.0 * paramScale) / paramScale - 1.f;\n\n            float minD = min( min(abs(mX), 1.0 - abs(mX)), min(abs(mY), 1.0 - abs(mY))) * 2.; // rect distace from flipping sign in [0,1]\n            float p = 6.;\n            float minDSmooth = pow(minD, 1. / p);\n            // TODO do some clever screen space derivative thing to prevent aliasing\n\n            float v = (mX * mY); // in [-1, 1], color switches at 0\n            float adjV = sign(v) * minDSmooth;\n\n            float s = smoothstep(-1.f, 1.f, adjV);\n\n            vec3 outColor = (1.-s)*color1 + s* color2;\n\n            gl_FragColor = lightSurfaceMat((1.-alpha) * outColor + alpha * edgeColor, Point);\n\n        }\n    `,l=new e({uniforms:{Matcap_r:{value:s},Matcap_g:{value:n},Matcap_b:{value:a},Matcap_k:{value:r},edgeColor:{value:new t(0,0,0)},edgeWidth:{value:0},color1:{value:new t(1,1,0)},color2:{value:new t(0,1,1)},paramScale:{value:1}},vertexShader:"\n        attribute vec3 barycoord;\n        attribute vec2 coord;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying vec2 Coord;\n\n        void main()\n        {\n            vec3 vNormal = ( mat3( modelViewMatrix ) * normal );\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Barycoord = barycoord;\n            Coord = coord;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:o});return l.side=i,l}function G(s,n,a,r){let o=`\n        ${S}\n        uniform vec3 color;\n\n        varying vec2 Point;\n\n        ${_}\n\n        void main(void){\n            gl_FragColor = lightSurfaceMat(color, Point);\n        }\n    `,l=new e({uniforms:{Matcap_r:{value:s},Matcap_g:{value:n},Matcap_b:{value:a},Matcap_k:{value:r},color:{value:new t(1,0,1)},scale:{value:1}},vertexShader:"\n        uniform float scale;\n        varying vec2 Point;\n\n        void main()\n        {\n            vec3 vNormal = (modelViewMatrix * instanceMatrix * vec4(normal, 0.)).xyz;\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( scale * position, 1.0 );\n\n        }\n    ",fragmentShader:o});return l.side=i,l}let N=1,W=[],D=new s;function A(e,t){let i=N,s=N+t;return W.push({start:i,end:s,structure:e}),N=s,i}function R(e,t,i,s,n,a,r){D.setSize(a,r),e.setRenderTarget(D),e.render(t,i);let o=new Uint8Array(4);return e.readRenderTargetPixels(D,s,D.height-n,1,1,o),function(e){for(let t of W)if(e>=t.start&&e<t.end)return{localInd:e-t.start,structure:t.structure};return{localInd:0,structure:void 0}}(o[0]+256*o[1]+256*o[2]*256)}function B(e){return[((255&e)>>0)/255,((65280&e)>>8)/255,((16711680&e)>>16)/255]}function z(e,t){if(t<0)return 0;let i=0,s=.5;for(;t>0;)t%2==1&&(i+=s),t/=2,s/=2;return i=(i+e)%1,n=i,Math.max(0,Math.min(1,n));var n}function q(e,t){return function(e,t,i){let s,n,a,r=Math.floor(6*e),o=6*e-r,l=i*(1-t),h=i*(1-o*t),d=i*(1-(1-o)*t);switch(r%6){case 0:s=i,n=d,a=l;break;case 1:s=h,n=i,a=l;break;case 2:s=l,n=i,a=d;break;case 3:s=l,n=h,a=i;break;case 4:s=d,n=l,a=i;break;case 5:s=i,n=l,a=h}return[255*s,255*n,255*a]}(z(e[0],t),e[1],e[2])}D.texture.generateMipmaps=!1;let L=[219/360,.88,.89],j=0;function O(){return q(L,j++)}const Q=["viridis","plasma","magma","inferno","coolwarm","blues","piyg","spectral","rainbow","jet","reds","hsv","rdpu"];function I(e){let t=e[0],i=e[0];return e.forEach((e=>{t=Math.min(t,e),i=Math.max(i,e)})),[t,i]}class H{constructor(s,a,r){this.parent=r,this.gp=this.parent.gp,this.values=a,this.name=s,this.enabled=!1,this.isDominantQuantity=!0,[this.dataMin,this.dataMax]=I(a);let o=function(s,n,a,r){let o=`\n        ${S}\n        uniform sampler2D colormap; // colormap\n        uniform vec3 edgeColor;\n        uniform float edgeWidth;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying float Value;\n\n        ${_}\n\n        void main(void){\n            float alpha = getEdgeFactor(Barycoord, vec3(1.,1.,1.), edgeWidth);\n            vec3 Color = sRGBToLinear(texture2D(colormap, vec2(Value, 0.5))).rgb;\n            gl_FragColor = lightSurfaceMat((1.-alpha) * Color + alpha * edgeColor, Point);\n        }\n    `,l=new e({uniforms:{Matcap_r:{value:s},Matcap_g:{value:n},Matcap_b:{value:a},Matcap_k:{value:r},colormap:{value:void 0},edgeColor:{value:new t(0,0,0)},edgeWidth:{value:0}},vertexShader:"\n        attribute vec3 barycoord;\n        attribute float value;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying float Value;\n\n        void main()\n        {\n            vec3 vNormal = ( mat3( modelViewMatrix ) * normal );\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Barycoord = barycoord;\n            Value = value;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:o});return l.side=i,l}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);this.mesh=new n(this.parent.mesh.geometry.clone(),o),this.initializeFunctionValues(),this.mesh.geometry.attributes.position=this.parent.mesh.geometry.attributes.position,this.mesh.geometry.attributes.normal=this.parent.mesh.geometry.attributes.normal,this.mesh.material.uniforms.edgeWidth=this.parent.mesh.material.uniforms.edgeWidth,this.mesh.material.uniforms.edgeColor=this.parent.mesh.material.uniforms.edgeColor}initGui(e,t){this.prefix=this.parent.name+"#"+this.name,this.guiFields=e,e[this.prefix+"#Enabled"]=!1,t.add(e,this.prefix+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.prefix+"#ColorMap"]="viridis",this.applyColorMap(e[this.prefix+"#ColorMap"]),t.add(e,this.prefix+"#ColorMap",Q).onChange((e=>{this.applyColorMap(e)})).listen().name("Color Map")}setEnabled(e){this.guiFields[this.prefix+"#Enabled"]=e,this.enabled=e,e?this.parent.enableQuantity(this):this.parent.disableQuantity(this)}setColorMap(e){this.guiFields[this.prefix+"#ColorMap"]=e,this.applyColorMap(e)}initializeFunctionValues(){let e=this.parent.faces.length,t=new Float32Array(3*e);for(let i=0;i<e;i++){let e=this.parent.faces[i];for(let s=0;s<3;s++){let n=this.values[e[s]];n=(n-this.dataMin)/(this.dataMax-this.dataMin),t[3*i+s]=n}}this.mesh.geometry.setAttribute("value",new a(t,1))}applyColorMap(e){this.mesh.material.uniforms.colormap.value=(new r).load(this.gp.geopticPath+"/img/colormaps/"+e+".png")}getVertexValue(e){return this.gp.prettyScalar(this.values[e])}getEdgeValue(e){}getFaceValue(e){}remove(){}}class ${constructor(t,s,n){this.parent=n,this.gp=this.parent.gp,this.values=s,this.name=t,this.enabled=!1,this.isDominantQuantity=!0,[this.dataMin,this.dataMax]=I(s);let a=function(t,s,n,a){let r=new e({uniforms:{Matcap_r:{value:t},Matcap_g:{value:s},Matcap_b:{value:n},Matcap_k:{value:a},colormap:{value:void 0},scale:{value:1}},vertexShader:"\n        uniform float scale;\n        attribute float value;\n\n        varying float Value;\n        varying vec2 Point;\n\n        void main()\n        {\n            vec3 vNormal = (modelViewMatrix * instanceMatrix * vec4(normal, 0.)).xyz;\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Value = value;\n\n            gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( scale * position, 1.0 );\n\n        }\n    ",fragmentShader:`\n        ${S}\n        uniform sampler2D colormap; // colormap\n\n        varying float Value;\n        varying vec2 Point;\n\n        ${_}\n\n        void main(void){\n            vec3 Color = sRGBToLinear(texture2D(colormap, vec2(Value, 0.5))).rgb;\n            gl_FragColor = lightSurfaceMat(Color, Point);\n        }\n    `});return r.side=i,r}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);this.mesh=new o(this.parent.mesh.geometry.clone(),a,this.parent.nV),this.mesh.geometry.attributes.position=this.parent.mesh.geometry.attributes.position,this.mesh.geometry.attributes.normal=this.parent.mesh.geometry.attributes.normal,this.mesh.material.uniforms.scale=this.parent.mesh.material.uniforms.scale,this.mesh.instanceMatrix=this.parent.mesh.instanceMatrix,this.initializeFunctionValues()}initGui(e,t){this.prefix=this.parent.name+"#"+this.name,this.guiFields=e,e[this.prefix+"#Enabled"]=!1,t.add(e,this.prefix+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.prefix+"#ColorMap"]="viridis",this.applyColorMap(e[this.prefix+"#ColorMap"]),t.add(e,this.prefix+"#ColorMap",Q).onChange((e=>{this.applyColorMap(e)})).listen().name("Color Map")}setEnabled(e){this.guiFields[this.prefix+"#Enabled"]=e,this.enabled=e,e?this.parent.enableQuantity(this):this.parent.disableQuantity(this)}initializeFunctionValues(){let e=new Float32Array(3*this.parent.nV);for(let t=0;t<this.parent.nV;t++){let i=this.values[t];i=(i-this.dataMin)/(this.dataMax-this.dataMin),e[t]=i}this.mesh.geometry.setAttribute("value",new l(e,1))}applyColorMap(e){this.mesh.material.uniforms.colormap.value=(new r).load(this.gp.geopticPath+"/img/colormaps/"+e+".png")}getVertexValue(e){return this.values[e]}getEdgeValue(e){}getFaceValue(e){}remove(){}}class U{constructor(s,a,o){this.parent=o,this.gp=this.parent.gp,this.values=a,this.name=s,this.enabled=!1,this.isDominantQuantity=!0,[this.dataMin,this.dataMax]=function(e){let t=e[0],i=e[0];return e.forEach((e=>{t=Math.min(t,e),i=Math.max(i,e)})),[t,i]}(a);let l=function(s,n,a,r){let o=`\n        ${S}\n        uniform sampler2D colormap; // colormap\n        uniform vec3 edgeColor;\n        uniform float edgeWidth;\n        uniform float scale;\n        uniform float offset;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying float Value;\n\n        ${_}\n\n        void main(void){\n            float v1 = Value * (1.-offset);\n            float v2 = Value * (1.-offset) + offset;\n\n            vec3 color1 = sRGBToLinear(texture2D(colormap, vec2(v1, 0.5))).rgb;\n            vec3 color2 = sRGBToLinear(texture2D(colormap, vec2(v2, 0.5))).rgb;\n\n            // Apply the stripe effect\n            float mX = mod(Value * 2.*scale, 2.)  - 1.f; // in [-1, 1]\n\n            float p = 6.;\n            float minDSmooth = pow(mX, 1. / p);\n            // TODO do some clever screen space derivative thing to prevent aliasing\n\n            float adjV = sign(mX) * minDSmooth;\n\n            float s = smoothstep(-1.f, 1.f, adjV);\n\n            vec3 outColor = (1.-s)*color1 + s* color2;\n\n            float alpha = getEdgeFactor(Barycoord, vec3(1.,1.,1.), edgeWidth);\n            gl_FragColor = lightSurfaceMat((1.-alpha) * outColor + alpha * edgeColor, Point);\n        }\n    `,l=new e({uniforms:{Matcap_r:{value:s},Matcap_g:{value:n},Matcap_b:{value:a},Matcap_k:{value:r},colormap:{value:void 0},edgeColor:{value:new t(0,0,0)},edgeWidth:{value:0},scale:{value:1},offset:{value:.2}},vertexShader:"\n        attribute vec3 barycoord;\n        attribute float value;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying float Value;\n\n        void main()\n        {\n            vec3 vNormal = ( mat3( modelViewMatrix ) * normal );\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Barycoord = barycoord;\n            Value = value;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:o});return l.side=i,l}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);this.mesh=new n(this.parent.mesh.geometry.clone(),l),this.mesh.material.uniforms.colormap.value=(new r).load(this.gp.geopticPath+"/img/colormaps/RdPu.png"),this.initializeDistances(this.values),this.mesh.geometry.attributes.position=this.parent.mesh.geometry.attributes.position,this.mesh.geometry.attributes.normal=this.parent.mesh.geometry.attributes.normal,this.mesh.material.uniforms.edgeWidth=this.parent.mesh.material.uniforms.edgeWidth,this.mesh.material.uniforms.edgeColor=this.parent.mesh.material.uniforms.edgeColor}initGui(e,t){this.prefix=this.parent.name+"#"+this.name,this.guiFields=e,e[this.prefix+"#Enabled"]=!1,t.add(e,this.prefix+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.name+"#Stripes"]=20,this.setStripes(e[this.name+"#Stripes"]),t.add(e,this.name+"#Stripes").min(0).max(50).step(.5).onChange((e=>{this.setStripes(e)})).listen().name("Stripes"),e[this.name+"#Offset"]=.2,this.setOffset(e[this.name+"#Offset"]),t.add(e,this.name+"#Offset").min(0).max(.5).step(.05).onChange((e=>{this.setOffset(e)})).listen().name("Offset"),e[this.prefix+"#ColorMap"]="rdpu",this.applyColorMap(e[this.prefix+"#ColorMap"]),t.add(e,this.prefix+"#ColorMap",Q).onChange((e=>{this.applyColorMap(e)})).listen().name("Color Map")}setEnabled(e){this.guiFields[this.prefix+"#Enabled"]=e,this.enabled=e,e?this.parent.enableQuantity(this):this.parent.disableQuantity(this)}setColorMap(e){this.guiFields[this.prefix+"#ColorMap"]=e,this.applyColorMap(e)}setStripes(e){this.mesh.material.uniforms.scale.value=e}setOffset(e){this.mesh.material.uniforms.offset.value=e}initializeDistances(e){let t=this.parent.faces.length,i=new Float32Array(3*t);for(let e=0;e<t;e++){let t=this.parent.faces[e];for(let s=0;s<3;s++){let n=this.values[t[s]];n=(n-this.dataMin)/(this.dataMax-this.dataMin),i[3*e+s]=n}}this.mesh.geometry.setAttribute("value",new a(i,1))}applyColorMap(e){this.mesh.material.uniforms.colormap.value=(new r).load(this.gp.geopticPath+"/img/colormaps/"+e+".png")}getVertexValue(e){return this.gp.prettyScalar(this.values[e])}getEdgeValue(e){}getFaceValue(e){}remove(){}}class X{constructor(e,t,i){this.parent=i,this.gp=this.parent.gp,this.values=t,this.name=e,this.enabled=!1,this.res=4,this.rad=.5,this.len=3,this.tipFrac=.3,this.widthFrac=.5,this.isDominantQuantity=!1,this.mesh=this.constructArrowMesh(this.parent.coords,t)}constructArrowMesh(e,i){let s=new h(this.rad*this.widthFrac,this.rad*this.widthFrac,this.len*(1-this.tipFrac),this.res),n=s.attributes.position.array,a=s.attributes.position.count,r=-this.len*(1-this.tipFrac)/2;for(let e=0;e<a;e++)n[3*e+1]=n[3*e+1]-r;let l=new h(0,this.rad,this.len*this.tipFrac,this.res);n=l.attributes.position.array,a=l.attributes.position.count,r=-this.len*this.tipFrac/2;for(let e=0;e<a;e++)n[3*e+1]=n[3*e+1]-r+this.len*(1-this.tipFrac);let m=new d;m.set(0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,1),s.applyMatrix4(m),l.applyMatrix4(m);let u=G(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);u.uniforms.scale.value=.05;let p=this.parent.nV;this.torsoMesh=new o(s,u,p),this.tipMesh=new o(l,u,p),m=new d;for(let e=0;e<p;e++){let s=this.parent.coords.get(e),n=i.get(e);m.lookAt(n,new t(0,0,0),new t(0,0,1)),m.setPosition(s[0],s[1],s[2]),this.torsoMesh.setMatrixAt(e,m),this.tipMesh.setMatrixAt(e,m)}let g=new c;return g.add(this.torsoMesh),g.add(this.tipMesh),g}initGui(e,t){this.prefix=this.parent.name+"#"+this.name,this.guiFields=e,e[this.prefix+"#Enabled"]=!1,t.add(e,this.prefix+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.name+"#Color"]=O(),this.setColor(e[this.name+"#Color"]),t.addColor(e,this.name+"#Color").onChange((e=>{this.setColor(e)})).listen().name("Color"),e[this.name+"#Radius"]=1,this.setRadius(e[this.name+"#Radius"]),t.add(e,this.name+"#Radius").min(0).max(5).step(.05).onChange((e=>{this.setRadius(e)})).listen().name("Radius")}setColor(e){let i=new t(e[0]/255,e[1]/255,e[2]/255);this.torsoMesh.material.uniforms.color.value=i,this.tipMesh.material.uniforms.color.value=i}setRadius(e){this.torsoMesh.material.uniforms.scale.value=.05*e,this.tipMesh.material.uniforms.scale.value=.05*e}setEnabled(e){this.guiFields[this.prefix+"#Enabled"]=e,this.enabled=e,e?this.parent.enableQuantity(this):this.parent.disableQuantity(this)}getVertexValue(e){let t=this.values.get(e),i=[t.x,t.y,t.z];return this.gp.prettyVector(i)}getEdgeValue(e){}getFaceValue(e){}}class Y{constructor(e,t,i){this.parent=i,this.gp=this.parent.gp,this.coords=t,this.name=e,this.enabled=!1,this.isDominantQuantity=!0;let s=T(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);this.mesh=new n(this.parent.mesh.geometry.clone(),s),this.initParam(t),this.mesh.geometry.attributes.position=this.parent.mesh.geometry.attributes.position,this.mesh.geometry.attributes.normal=this.parent.mesh.geometry.attributes.normal,this.mesh.material.uniforms.edgeWidth=this.parent.mesh.material.uniforms.edgeWidth,this.mesh.material.uniforms.edgeColor=this.parent.mesh.material.uniforms.edgeColor}initGui(e,t){this.prefix=this.parent.name+"#"+this.name,this.guiFields=e,e[this.prefix+"#Enabled"]=!1,t.add(e,this.prefix+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.prefix+"#Style"]="checker",t.add(e,this.prefix+"#Style",["checker","grid"]).onChange((e=>{this.applyStyle(e)})).listen().name("Color Map"),e[this.name+"#Color1"]=[249,45,94],this.setColor1(e[this.name+"#Color1"]),t.addColor(e,this.name+"#Color1").onChange((e=>{this.setColor1(e)})).listen().name("Color"),e[this.name+"#Color2"]=[249,219,225],this.setColor2(e[this.name+"#Color2"]),t.addColor(e,this.name+"#Color2").onChange((e=>{this.setColor2(e)})).listen().name("Color"),e[this.name+"#Scale"]=1,this.setScale(e[this.name+"#Scale"]),t.add(e,this.name+"#Scale").min(0).max(2).step(.05).onChange((e=>{this.setScale(e)})).listen().name("Scale")}setScale(e){this.mesh.material.uniforms.paramScale.value=e/10}setColor1(e){let i=new t(e[0]/255,e[1]/255,e[2]/255);this.mesh.material.uniforms.color1.value=i}setColor2(e){let i=new t(e[0]/255,e[1]/255,e[2]/255);this.mesh.material.uniforms.color2.value=i}setEnabled(e){this.guiFields[this.prefix+"#Enabled"]=e,this.enabled=e,e?this.parent.enableQuantity(this):this.parent.disableQuantity(this)}applyStyle(s){"checker"==s?this.mesh.material=T(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k):"grid"==s&&(this.mesh.material=function(s,n,a,r){let o=`\n        ${S}\n        uniform vec3 edgeColor;\n        uniform float edgeWidth;\n        uniform vec3 color1;\n        uniform vec3 color2;\n        uniform float paramScale;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying vec2 Coord;\n\n        ${_}\n\n        void main(void){\n            float alpha = getEdgeFactor(Barycoord, vec3(1.,1.,1.), edgeWidth);\n\n\n            // Apply the checkerboard effect\n            float mX = mod(Coord.x, 2.0 * paramScale) / paramScale - 1.f; // in [-1, 1]\n            float mY = mod(Coord.y, 2.0 * paramScale) / paramScale - 1.f;\n\n\n            // rect distace from flipping sign in [0,1]\n            float minD = min(min(abs(mX), 1.0 - abs(mX)), min(abs(mY), 1.0 - abs(mY))) * 2.;\n\n            float width = 0.05;\n            float slopeWidthPix = 10.;\n\n            vec2 fw = fwidth(Coord);\n            float scale = max(fw.x, fw.y);\n            float pWidth = slopeWidthPix * scale;\n\n            float s = smoothstep(width, width + pWidth, minD);\n\n            vec3 outColor = (1.-s)*color1 + s* color2;\n\n            gl_FragColor = lightSurfaceMat((1.-alpha) * outColor + alpha * edgeColor, Point);\n\n        }\n    `,l=new e({uniforms:{Matcap_r:{value:s},Matcap_g:{value:n},Matcap_b:{value:a},Matcap_k:{value:r},edgeColor:{value:new t(0,0,0)},edgeWidth:{value:0},color1:{value:new t(1,1,0)},color2:{value:new t(0,1,1)},paramScale:{value:1}},vertexShader:"\n        attribute vec3 barycoord;\n        attribute vec2 coord;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying vec2 Coord;\n\n        void main()\n        {\n            vec3 vNormal = ( mat3( modelViewMatrix ) * normal );\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Barycoord = barycoord;\n            Coord = coord;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:o});return l.side=i,l}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k)),this.setColor1(this.guiFields[this.name+"#Color1"]),this.setColor2(this.guiFields[this.name+"#Color2"]),this.setScale(this.guiFields[this.name+"#Scale"]),this.mesh.material.uniforms.edgeWidth=this.parent.mesh.material.uniforms.edgeWidth,this.mesh.material.uniforms.edgeColor=this.parent.mesh.material.uniforms.edgeColor}initParam(e){let t=this.parent.faces.length,i=new Float32Array(3*t*2);for(let s=0;s<t;s++){let t=this.parent.faces[s];for(let n=0;n<3;n++){let a=e[t[n]];for(let e=0;e<2;++e)i[6*s+2*n+e]=a[e]}}this.mesh.geometry.setAttribute("coord",new a(i,2))}getVertexValue(e){return this.gp.prettyVector2(this.coords[e])}getEdgeValue(e){}getFaceValue(e){}remove(){}}function Z(e){let t,i,s;t=e.get?t=>e.get(t):t=>e[t],i=t(0).x?function(e,t){return 0==t?e.x:1==t?e.y:e.z}:(e,t)=>e[t],s=e.size?e.size():e.length;const n=[];let a;for(let e=0;e<s;e++)a=t(e),n.push([i(a,0),i(a,1),i(a,2)]);return n}function J(e){let t,i,s=!1;e.get?"number"==typeof e.get(0)||"bigint"==typeof e.get(0)?(s=!0,t=t=>[e.get(3*t),e.get(3*t+1),e.get(3*t+2)]):t=e.get(0).get?t=>[e.get(t).get(0),e.get(t).get(1),e.get(t).get(2)]:t=>e.get(t):"number"==typeof e[0]||"bigint"==typeof e[0]?(s=!0,t=t=>[e[3*t],e[3*t+1],e[3*t+2]]):t=t=>e[t],i=e.size?e.size():e.length,s&&(i/=3);const n=[];for(let e=0;e<i;e++)n.push([t(e)[0],t(e)[1],t(e)[2]]);return n}class K{constructor(e,t,i,s,n={}){this.gp=s,this.nV=e.length,this.coords=e,this.faces=t,this.name=i,this.enabled=!0,this.color=n.color||O(),[this.mesh,this.geo]=this.constructThreeMesh(e,t),[this.smoothVertexNormals,this.smoothCornerNormals]=this.computeSmoothNormals(),this.gp.doPicks&&(this.pickMesh=this.constructThreePickMesh(e,t)),this.quantities={},this.setSmoothShading(!0),this.guiFields=void 0,this.guiFolder=void 0,this.vertexPickCallback=e=>{},this.edgePickCallback=e=>{},this.facePickCallback=e=>{}}addVertexScalarQuantity(e,t){this.quantities[e]=new H(e,t,this),this.guiFolder.removeFolder(e);let i=this.guiFolder.addFolder(e);return this.quantities[e].initGui(this.guiFields,i),this.quantities[e]}addVertexDistanceQuantity(e,t){this.quantities[e]=new U(e,t,this),this.guiFolder.removeFolder(e);let i=this.guiFolder.addFolder(e);return this.quantities[e].initGui(this.guiFields,i),this.quantities[e]}addVertexVectorQuantity(e,t){t=Z(t),this.quantities[e]=new X(e,t,this),this.guiFolder.removeFolder(e);let i=this.guiFolder.addFolder(e);return this.quantities[e].initGui(this.guiFields,i),this.quantities[e]}addVertexParameterizationQuantity(e,t){t=function(e){let t,i,s;t=e.get?t=>e.get(t):t=>e[t],i=t(0).x?function(e,t){return 0==t?e.x:e.y}:(e,t)=>e[t],s=e.size?e.size():e.length;const n=[];let a;for(let e=0;e<s;e++)a=t(e),n.push([i(a,0),i(a,1)]);return n}(t),this.quantities[e]=new Y(e,t,this),this.guiFolder.removeFolder(e);let i=this.guiFolder.addFolder(e);return this.quantities[e].initGui(this.guiFields,i),this.quantities[e]}initGui(e,t){this.guiFields=e,this.guiFolder=t;let i=t.domElement.firstChild,s=document.createElement("li");s.classList.add("dat-info-box"),i.appendChild(s);let n=document.createElement("span");n.innerHTML="#verts: "+this.nV;let a=document.createElement("span");a.innerHTML="   #faces: "+this.faces.length,s.appendChild(n),s.appendChild(a),e[this.name+"#Enabled"]=!0;let r=t.add(e,this.name+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled").domElement.closest("li");r.classList.add("half-button"),r.style.width="35%",e[this.name+"#Smooth"]=!0;r=t.add(e,this.name+"#Smooth").onChange((e=>{this.setSmoothShading(e)})).listen().name("Smooth").domElement.closest("li"),r.classList.add("half-button"),r.style.width="35%",e[this.name+"#Edges"]=!1;r=t.add(e,this.name+"#Edges").onChange((e=>{this.setEdgesEnabled(e)})).listen().name("Edges").domElement.closest("li"),r.classList.add("half-button"),r.style.width="30%",e[this.name+"#Color"]=this.color,this.setColor(e[this.name+"#Color"]),t.addColor(e,this.name+"#Color").onChange((e=>{this.setColor(e)})).listen().name("Color"),e[this.name+"#Edge Width"]=0,this.edgeWidth=1;r=t.add(e,this.name+"#Edge Width").min(0).max(2).step(.05).onChange((e=>{this.edgeWidth=e,this.mesh.material.uniforms.edgeWidth.value=e})).listen().name("Edge Width").domElement.closest("li"),r.style.display="none",this.edgeGuis=[r],e[this.name+"#Edge Color"]=[0,0,0];r=t.addColor(e,this.name+"#Edge Color").onChange((e=>{this.setEdgeColor(e)})).listen().name("Edge Color").domElement.closest("li"),r.style.display="none",this.edgeGuis.push(r),t.open()}setEdgesEnabled(e){this.guiFields[this.name+"#Edges"]=e;for(let t of this.edgeGuis)t.style.display=e?"block":"none";e?(this.mesh.material.uniforms.edgeWidth.value=this.edgeWidth,this.guiFields[this.name+"#Edge Width"]=this.edgeWidth):(this.mesh.material.uniforms.edgeWidth.value=0,this.guiFields[this.name+"#Edge Width"]=0)}setSmoothShading(e){e?this.mesh.geometry.attributes.normal.array=new Float32Array(this.smoothCornerNormals):this.mesh.geometry.computeVertexNormals(),this.mesh.geometry.attributes.normal.needsUpdate=!0}setColor(e){this.color=e;let i=new t(e[0]/255,e[1]/255,e[2]/255);this.mesh.material.uniforms.color.value=i}getColor(){return this.color}setEdgeColor(e){let i=new t(e[0]/255,e[1]/255,e[2]/255);this.mesh.material.uniforms.edgeColor.value=i}setEnabled(e){if(this.enabled=e,this.guiFields[this.name+"#Enabled"]=e,e){let e=!1;for(let t in this.quantities)this.quantities[t].enabled&&(this.gp.scene.add(this.quantities[t].mesh),e=!0);e||this.gp.scene.add(this.mesh),this.gp.doPicks&&this.gp.pickScene.add(this.pickMesh)}else{for(let e in this.quantities)this.gp.scene.remove(this.quantities[e].mesh);this.gp.scene.remove(this.mesh),this.gp.doPicks&&this.gp.pickScene.remove(this.pickMesh)}}enableQuantity(e){if(e.isDominantQuantity)for(let t in this.quantities){let i=this.quantities[t];i.isDominantQuantity&&t!=e.name&&(this.guiFields[i.prefix+"#Enabled"]=!1,i.enabled=!1,this.gp.scene.remove(i.mesh))}this.enabled&&(e.isDominantQuantity&&this.gp.scene.remove(this.mesh),this.gp.scene.add(e.mesh))}disableQuantity(e){this.enabled&&(this.gp.scene.remove(e.mesh),this.gp.scene.add(this.mesh))}remove(){for(let e in this.quantities)this.gp.scene.remove(this.quantities[e].mesh),this.quantities[e].remove();this.quantities={}}computeSmoothNormals(){let e=this.nV,i=this.faces.length,s=new Float32Array(3*e);for(let t=0;t<e;++t)s[3*t+0]=0,s[3*t+1]=0,s[3*t+2]=0;const n=this.mesh.geometry.attributes.normal.array;for(let e=0;e<i;e++){let t=this.faces[e];for(let i=0;i<3;i++){let a=t[i];for(let t=0;t<3;++t)s[3*a+t]+=n[9*e+3*i+t]}}for(let i=0;i<e;++i){let e=new t(s[3*i+0],s[3*i+1],s[3*i+2]);e.normalize(),s[3*i+0]=e.x,s[3*i+1]=e.y,s[3*i+2]=e.z}let a=new Float32Array(3*i*3);for(let e=0;e<i;e++){let t=this.faces[e];for(let i=0;i<3;i++)for(let n=0;n<3;++n)a[9*e+3*i+n]=s[3*t[i]+n]}return[s,a]}setPosition(e){let i=new m(this.mesh.rotation.x,this.mesh.rotation.y,this.mesh.rotation.z);this.mesh.setRotationFromAxisAngle(new t(1,0,0),0),this.gp.doPicks&&this.pickMesh.setRotationFromAxisAngle(new t(1,0,0),0);let s=this.mesh.position;this.mesh.translateX(e.x-s.x,1),this.mesh.translateY(e.y-s.y,1),this.mesh.translateZ(e.z-s.z,1),this.gp.doPicks&&(s=this.pickMesh.position,this.pickMesh.translateX(e.x-s.x,1),this.pickMesh.translateY(e.y-s.y,1),this.pickMesh.translateZ(e.z-s.z,1)),this.mesh.setRotationFromEuler(i),this.pickMesh.setRotationFromEuler(i)}setOrientationFromMatrix(e){this.mesh.setRotationFromAxisAngle(new t(1,0,0),0),this.mesh.setRotationFromMatrix(e),this.gp.doPicks&&(this.pickMesh.setRotationFromAxisAngle(new t(1,0,0),0),this.pickMesh.setRotationFromMatrix(e))}setOrientationFromFrame(e,t,i){let s=new d;s.set(-e.x,t.x,-i.x,0,-e.y,t.y,-i.y,0,-e.z,t.z,-i.z,0,0,0,0,1),this.setOrientationFromMatrix(s)}constructThreeMesh(s,r){let o=new u,l=r.length,h=new Float32Array(3*l*3),d=new Float32Array(3*l*3);for(let e=0;e<l;e++){let t=r[e];for(let i=0;i<3;i++){let n=s[t[i]];for(let t=0;t<3;++t)h[9*e+3*i+t]=n[t],d[9*e+3*i+t]=t==i?1:0}}o.setAttribute("position",new a(h,3)),o.setAttribute("barycoord",new a(d,3)),o.computeVertexNormals();let c=function(s,n,a,r){let o=`\n        ${S}\n        uniform vec3 color;\n        uniform vec3 edgeColor;\n        uniform float edgeWidth;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n\n        ${_}\n\n        void main(void){\n            float alpha = getEdgeFactor(Barycoord, vec3(1.,1.,1.), edgeWidth);\n            gl_FragColor = lightSurfaceMat((1.-alpha) * color + alpha * edgeColor, Point);\n        }\n    `,l=new e({uniforms:{Matcap_r:{value:s},Matcap_g:{value:n},Matcap_b:{value:a},Matcap_k:{value:r},color:{value:new t(1,0,1)},edgeColor:{value:new t(0,0,0)},edgeWidth:{value:0}},vertexShader:"\n        attribute vec3 barycoord;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n\n        void main()\n        {\n            vec3 vNormal = ( mat3( modelViewMatrix ) * normal );\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Barycoord = barycoord;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:o});return l.side=i,l}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);return[new n(o,c),o]}pickElement(e){if(e<this.facePickIndStart){this.gp.setDataHeader(`Surface Mesh ${this.name}`,`Vertex ${e}`),this.gp.clearDataFields(),this.gp.showDataField("position",this.gp.prettyVector(this.coords[e]));for(let t in this.quantities){let i=this.quantities[t].getVertexValue(e);i&&this.gp.showDataField(t,i)}this.vertexPickCallback(e)}else if(e<this.edgePickIndStart){const t=e-this.facePickIndStart;this.gp.setDataHeader(`Surface Mesh ${this.name}`,`Face ${t}`),this.gp.clearDataFields(),this.facePickCallback(t)}else{const t=e-this.edgePickIndStart;this.gp.setDataHeader(`Surface Mesh ${this.name}`,`Edge ${t}`),this.gp.clearDataFields(),this.edgePickCallback(t)}}constructThreePickMesh(t,s){let r=new u,o=(e,t)=>[Math.min(e,t),Math.max(e,t)],l=s.length,h=0;this.edges=[];let d={};for(let e=0;e<l;e++){let t=s[e];for(let e=0;e<3;++e){h=Math.max(h,t[e]+1);let i=o(t[e],t[(e+1)%3]);i in d||(d[i]=this.edges.length,this.edges.push(i))}}let c=h+this.edges.length+l;this.facePickIndStart=h,this.edgePickIndStart=this.facePickIndStart+l;let m=A(this,c),p=m+h,g=p+l,v=new Float32Array(9*l),f=new Float32Array(9*l),y=new Float32Array(9*l),x=new Float32Array(9*l),b=new Float32Array(9*l),C=new Float32Array(9*l),M=new Float32Array(9*l);for(let e=0;e<l;e++){let t=s[e],i=B(e+p),n=[0,1,2].map((e=>B(m+t[e]))),a=[1,2,0].map((e=>{let i=o(t[e],t[(e+1)%3]);return B(g+d[i])}));for(let s=0;s<3;s++){t[s];for(let t=0;t<3;++t)M[9*e+3*s+t]=i[t],v[9*e+3*s+t]=n[0][t],f[9*e+3*s+t]=n[1][t],y[9*e+3*s+t]=n[2][t],x[9*e+3*s+t]=a[2][t],b[9*e+3*s+t]=a[0][t],C[9*e+3*s+t]=a[1][t]}}r.setAttribute("position",this.mesh.geometry.attributes.position),r.setAttribute("barycoord",this.mesh.geometry.attributes.barycoord),r.setAttribute("vertex_color0",new a(v,3)),r.setAttribute("vertex_color1",new a(f,3)),r.setAttribute("vertex_color2",new a(y,3)),r.setAttribute("edge_color0",new a(x,3)),r.setAttribute("edge_color1",new a(b,3)),r.setAttribute("edge_color2",new a(C,3)),r.setAttribute("face_color",new a(M,3));let w=function(){let t=new e({vertexShader:"\n        attribute vec3 barycoord;\n        attribute vec3 color;\n        attribute vec3 vertex_color0;\n        attribute vec3 vertex_color1;\n        attribute vec3 vertex_color2;\n        attribute vec3 edge_color0;\n        attribute vec3 edge_color1;\n        attribute vec3 edge_color2;\n        attribute vec3 face_color;\n\n        varying vec3 BaryCoord;\n        varying vec3 VertexColor0;\n        varying vec3 VertexColor1;\n        varying vec3 VertexColor2;\n        varying vec3 EdgeColor0;\n        varying vec3 EdgeColor1;\n        varying vec3 EdgeColor2;\n        varying vec3 FaceColor;\n\n\n        void main()\n        {\n            BaryCoord = barycoord;\n            VertexColor0 = vertex_color0;\n            VertexColor1 = vertex_color1;\n            VertexColor2 = vertex_color2;\n            EdgeColor0 = edge_color0;\n            EdgeColor1 = edge_color1;\n            EdgeColor2 = edge_color2;\n            FaceColor = face_color;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:"\n        varying vec3 BaryCoord;\n        varying vec3 VertexColor0;\n        varying vec3 VertexColor1;\n        varying vec3 VertexColor2;\n        varying vec3 EdgeColor0;\n        varying vec3 EdgeColor1;\n        varying vec3 EdgeColor2;\n        varying vec3 FaceColor;\n\n        void main(void){\n\n            // Parameters defining the pick shape (in barycentric 0-1 units)\n            float vertRadius = 0.2;\n            float edgeRadius = 0.2;\n\n            vec3 shadeColor = FaceColor;\n\n            // Test vertices\n            if (BaryCoord[0] > 1.0-vertRadius) {\n                shadeColor = VertexColor0;\n            } else if(BaryCoord[1] > 1.0-vertRadius) {\n                shadeColor = VertexColor1;\n            } else if (BaryCoord[2] > 1.0-vertRadius) {\n                shadeColor = VertexColor2;\n            } else if (BaryCoord[2] < edgeRadius) {\n                shadeColor = EdgeColor0;\n            } else if (BaryCoord[0] < edgeRadius) {\n                shadeColor = EdgeColor1;\n            } else if (BaryCoord[1] < edgeRadius) {\n                shadeColor = EdgeColor2;\n            }\n\n            gl_FragColor = vec4(shadeColor, 1.);\n        }\n    "});return t.side=i,t}();return new n(r,w)}updatePositions(){}}class ee{constructor(e,t,i,s={}){this.gp=i,this.nV=e.length,this.coords=e,this.name=t,this.enabled=!0,this.color=s.color||O(),this.mesh=this.constructThreeMesh(e),this.gp.doPicks&&(this.pickMesh=this.constructThreePickMesh(e)),this.quantities={},this.guiFields=void 0,this.guiFolder=void 0}addScalarQuantity(e,t){this.quantities[e]=new $(e,t,this);let i=this.guiFolder.addFolder(e);this.quantities[e].initGui(this.guiFields,i)}initGui(e,t){this.guiFields=e,this.guiFolder=t;let i=t.domElement.firstChild,s=document.createElement("li");s.classList.add("dat-info-box"),i.appendChild(s);let n=document.createElement("span");n.innerHTML="#verts: "+this.nV,s.appendChild(n),e[this.name+"#Enabled"]=!0,t.add(e,this.name+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.name+"#Color"]=this.color,this.setColor(e[this.name+"#Color"]),t.addColor(e,this.name+"#Color").onChange((e=>{this.setColor(e)})).listen().name("Color"),e[this.name+"#Radius"]=1,this.setRadius(e[this.name+"#Radius"]),t.add(e,this.name+"#Radius").min(0).max(5).step(.05).onChange((e=>{this.setRadius(e)})).listen().name("Radius"),t.open()}setColor(e){this.color=e;let i=new t(e[0]/255,e[1]/255,e[2]/255);this.mesh.material.uniforms.color.value=i}getColor(){return this.color}setRadius(e){this.mesh.material.uniforms.scale.value=e,this.gp.doPicks&&(this.pickMesh.material.uniforms.scale.value=e)}setEnabled(e){if(this.guiFields[this.name+"#Enabled"]=e,this.enabled=e,e){let e=!1;for(let t in this.quantities)this.quantities[t].enabled&&(this.gp.scene.add(this.quantities[t].mesh),e=!0);e||this.gp.scene.add(this.mesh),this.gp.doPicks&&this.gp.pickScene.add(this.pickMesh)}else{for(let e in this.quantities)this.gp.scene.remove(this.quantities[e].mesh);this.gp.scene.remove(this.mesh),this.gp.doPicks&&this.gp.pickScene.remove(this.pickMesh)}}enableQuantity(e){if(e.isDominantQuantity)for(let t in this.quantities){let i=this.quantities[t];i.isDominantQuantity&&t!=e.name&&(this.guiFields[i.prefix+"#Enabled"]=!1,i.enabled=!1,this.gp.scene.remove(i.mesh))}this.enabled&&(e.isDominantQuantity&&this.gp.scene.remove(this.mesh),this.gp.scene.add(e.mesh))}disableQuantity(e){this.enabled&&(this.gp.scene.remove(e.mesh),this.gp.scene.add(this.mesh))}remove(){for(let e in this.quantities)this.gp.scene.remove(this.quantities[e].mesh),this.quantities[e].remove();this.quantities={}}constructThreeMesh(e){let t=new p(.025,2),i=G(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k),s=new o(t,i,this.nV),n=new d;new Float32Array(3*this.nV);for(let t=0;t<this.nV;t++){let i=e[t];n.setPosition(i[0],i[1],i[2]),s.setMatrixAt(t,n)}return s}pickElement(e){this.gp.setDataHeader(`Point Cloud ${this.name}`,`Vertex ${e}`),this.gp.clearDataFields(),this.gp.showDataField("position",this.gp.prettyVector(this.coords[e]));for(let t in this.quantities){let i=this.quantities[t].getVertexValue(e);i&&this.gp.showDataField(t,i)}}constructThreePickMesh(t){let i=this.nV,s=new Float32Array(3*this.nV),n=A(this,i);for(let e=0;e<this.nV;e++){let t=B(e+n);for(let i=0;i<3;++i)s[3*e+ +i]=t[i]}let a=new e({vertexShader:"\n        uniform float scale;\n        attribute vec3 color;\n\n        varying vec3 Color;\n\n\n        void main()\n        {\n            Color = color;\n\n            gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( scale * position, 1.0 );\n\n        }\n    ",fragmentShader:"\n        varying vec3 Color;\n\n        void main(void){\n            gl_FragColor = vec4(Color, 1.);\n        }\n    "}),r=new o(this.mesh.geometry.clone(),a,this.nV);return r.geometry.setAttribute("color",new l(s,3)),r.geometry.attributes.position=this.mesh.geometry.attributes.position,r.material.uniforms.scale=this.mesh.material.uniforms.scale,r.instanceMatrix=this.mesh.instanceMatrix,r}updatePositions(){}}class te{constructor(e,t,i,s,n,a={}){this.gp=n,this.res=12,this.color=a.color||O(),[this.mesh,this.tubeMesh,this.pointMesh]=this.constructThreeCurveNetwork(e,t,i),this.nV=e.length,this.segments=t,this.maxLen=i,this.name=s,this.quantities={},this.guiFields=void 0,this.guiFolder=void 0}setEnabled(e){this.guiFields[this.name+"#Enabled"]=e,e?this.gp.scene.add(this.mesh):this.gp.scene.remove(this.mesh)}remove(){for(let e in this.quantities)this.gp.scene.remove(this.quantities[e].mesh),this.quantities[e].remove();this.quantities={}}updateVertexPositions(e){const i=this.tubeMesh.geometry.attributes.len.array;let s=new d;for(let n=0;n<this.segments.length;n++){let a=this.gp.listToVec(e[this.segments[n][0]]),r=this.gp.listToVec(e[this.segments[n][1]]),o=new t;o.subVectors(a,r),i[n]=o.length(),s.lookAt(new t(0,0,0),o,new t(0,0,1)),s.setPosition(a.x,a.y,a.z),this.tubeMesh.setMatrixAt(n,s),this.pointMesh.setMatrixAt(this.segments[n][0],s),this.pointMesh.setMatrixAt(this.segments[n][1],s)}this.tubeMesh.geometry.attributes.len.needsUpdate=!0,this.tubeMesh.instanceMatrix.needsUpdate=!0,this.pointMesh.instanceMatrix.needsUpdate=!0}setColor(e){this.color=e;let i=new t(e[0]/255,e[1]/255,e[2]/255);this.tubeMesh.material.uniforms.color.value=i,this.pointMesh.material.uniforms.color.value=i}getColor(){return this.color}setEdgeWidth(e){this.tubeMesh.material.uniforms.rad.value=e/100,this.pointMesh.material.uniforms.scale.value=e/100}initGui(e,t){this.guiFields=e,this.guiFolder=t;let i=t.domElement.firstChild,s=document.createElement("li");s.classList.add("dat-info-box"),i.appendChild(s);let n=document.createElement("span");n.innerHTML="#verts: "+this.nV;let a=document.createElement("span");a.innerHTML="   #edges: "+this.segments.length,s.appendChild(n),s.appendChild(a),e[this.name+"#Enabled"]=!0,t.add(e,this.name+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.name+"#Color"]=this.color,this.setColor(e[this.name+"#Color"]),t.addColor(e,this.name+"#Color").onChange((e=>{this.setColor(e)})).listen().name("Color"),e[this.name+"#Width"]=1,this.setEdgeWidth(e[this.name+"#Width"]),t.add(e,this.name+"#Width").min(0).max(50).step(.25).onChange((e=>{this.setEdgeWidth(e)})).listen().name("Edge Width"),t.open()}constructThreeCurveNetwork(s,n,a){let r=new h(1,1,1,this.res),m=new g(1,this.res,this.res),u=r.attributes.position.array,p=r.attributes.position.count;for(let e=0;e<p;e++)u[3*e+1]=u[3*e+1]- -.5;let v=new d;v.set(0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,1),r.applyMatrix4(v),m.applyMatrix4(v);let f=function(s,n,a,r){let o=`\n        ${S}\n        uniform vec3 color;\n\n        varying vec2 Point;\n\n        ${_}\n\n        void main(void){\n            gl_FragColor = lightSurfaceMat(color, Point);\n        }\n    `,l=new e({uniforms:{Matcap_r:{value:s},Matcap_g:{value:n},Matcap_b:{value:a},Matcap_k:{value:r},color:{value:new t(1,0,1)},rad:{value:1}},vertexShader:"\n        uniform float rad;\n        attribute float len;\n\n        varying vec2 Point;\n\n        void main()\n        {\n            vec3 vNormal = (modelViewMatrix * instanceMatrix * vec4(normal, 0.)).xyz;\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            vec3 scaled_position = vec3(position.x * rad, position.y*rad, position.z*len);\n            gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( scaled_position, 1.0 );\n\n        }\n    ",fragmentShader:o});return l.side=i,l}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);f.uniforms.rad.value=.05;let y=G(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);y.uniforms.scale.value=.05;let x=new o(r,f,n.length),b=new o(m,y,s.length),C=new Float32Array(n.length);v=new d;for(let e=0;e<n.length;e++){let i=this.gp.listToVec(s[n[e][0]]),a=this.gp.listToVec(s[n[e][1]]),r=new t;r.subVectors(i,a),C[e]=r.length(),v.lookAt(new t(0,0,0),r,new t(0,0,1)),v.setPosition(i.x,i.y,i.z),x.setMatrixAt(e,v),b.setMatrixAt(n[e][0],v),b.setMatrixAt(n[e][1],v)}x.geometry.setAttribute("len",new l(C,1));let M=new c;return M.add(x),M.add(b),[M,x,b]}}V.prototype.removeFolder=function(e){var t=this.__folders[e];t&&(t.close(),this.__ul.removeChild(t.domElement.parentNode),delete this.__folders[e],this.onResize())};class ie{constructor(e={}){k.isWebGLAvailable()||alert(k.getWebGLErrorMessage()),this.geopticPath=e.path||"js/geoptic.js",this.parent=e.parent||document.body,this.input=void 0,this.renderer=void 0,this.scene=void 0,this.camera=void 0,this.controls=void 0,this.shiftClick=!1,this.matcapTextures=void 0,this.pickRenderer=void 0,this.pickScene=void 0,this.surfaceMeshes={},this.curveNetworks={},this.pointClouds={},this.mesh=void 0,this.geo=void 0,this.structureGui=void 0,this.structureGuiFields={},this.structureGuiMeshes=void 0,this.structureGuiCurveNetworks=void 0,this.structureGuiPointClouds=void 0,this.commandGui=new V({resizeable:!0}),this.commandGuiFields={};let i=document.createElement("div");this.parent.appendChild(i),i.id="command-gui",i.appendChild(this.commandGui.domElement),this.groundPlane=void 0,this.onMeshLoad=e=>{},this.userCallback=()=>{},this.sceneMin=new t(0,0,0),this.sceneMax=new t(0,0,0),this.doPicks=e.hasOwnProperty("picks")&&e.picks||!e.hasOwnProperty("picks"),this.init()}initInput(){let e=document.createElement("div");this.input=document.createElement("input"),e.appendChild(this.input),document.body.appendChild(e),this.input.id="fileInput",this.input.style.display="none",this.input.type="file"}init(){this.initInput(),this.input.addEventListener("change",function(e){document.getElementById("spinner").style.display="inline-block";let t=this.input.files[0];if(t.name.endsWith(".obj")){let e=new FileReader;e.onload=function(t){this.onMeshLoad(e.result),document.getElementById("spinner").style.display="none"}.bind(this),e.onerror=function(e){alert("Unable to load OBJ file"),document.getElementById("spinner").style.display="none"},e.readAsText(t)}else alert("Please load an OBJ file"),document.getElementById("spinner").style.display="none"}.bind(this)),this.initDOM(),this.stats=new P,this.stats.dom.style.position="absolute",this.container.append(this.stats.dom),this.initRenderer(this.container),this.initMatcap(),this.initGUI(),this.initCamera(),this.initScene(),this.initLights(),this.initControls(),this.initGroundPlane(),this.addEventListeners()}initDOM(){if(this.container=document.createElement("div"),this.container.style.height="100%",this.container.style.overflow="hidden",this.container.style.position="relative",this.parent.appendChild(this.container),this.doPicks){let e=document.createElement("div");e.id="selection-info";let t=document.createElement("div");t.id="info-head";let i=document.createElement("div");i.id="info-head-structure";let s=document.createElement("div");s.id="info-head-name";let n=document.createElement("div");n.id="info-body";let a=document.createElement("div");a.id="info-body-field-names";let r=document.createElement("div");r.id="info-body-field-values",n.appendChild(a),n.appendChild(r),t.appendChild(i),t.appendChild(s),e.appendChild(t),e.appendChild(n),this.container.appendChild(e)}let e=document.createElement("div");e.id="messages",this.container.appendChild(e)}initGroundPlane(){let e=(new r).load(this.geopticPath+"/img/concrete.png");this.groundPlane=new E(new v(100,100),{clipBias:.003,textureWidth:this.parent.offsetWidth*window.devicePixelRatio,textureHeight:this.parent.offsetHeight*window.devicePixelRatio,color:7829367}),this.groundPlane.material.vertexShader="\n  uniform mat4 textureMatrix;\n  attribute vec2 texture_uv;\n\n  varying vec4 vUv;\n  varying vec2 TextureUV;\n\n  void main() {\n\n  \tvUv = textureMatrix * vec4( position, 1.0 );\n\n    TextureUV = texture_uv;\n\n  \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n  }\n",this.groundPlane.material.fragmentShader="\n    uniform vec3 color;\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tex;\n    uniform float alpha;\n\n    varying vec2 TextureUV;\n    varying vec4 vUv;\n\n    float blendOverlay( float base, float blend ) {\n        return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n    }\n\n    vec3 blendOverlay( vec3 base, vec3 blend ) {\n        return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n    }\n\n    float onGrid(vec2 coord2D) {\n        // Checker stripes\n        float modDist = min(min(mod(coord2D.x, 1.0), mod(coord2D.y, 1.0)), min(mod(-coord2D.x, 1.0), mod(-coord2D.y, 1.0)));\n        return 1.-smoothstep(0.005, .02, modDist);\n    }\n\n    void main() {\n\n        vec4 mat = texture2D(tex, TextureUV);\n        vec4 base = texture2DProj( tDiffuse, vUv );\n        float t = onGrid(26.*TextureUV);\n\n        gl_FragColor = (1.-t) * ((1.-alpha) * vec4( blendOverlay( base.rgb, color ), 1.0 ) + alpha * mat) + t*vec4(0.3,0.3,0.3,1.);\n\n    }\n",this.groundPlane.material.uniforms.tex={value:e},this.groundPlane.material.uniforms.alpha={value:.5},this.groundPlane.geometry.setAttribute("texture_uv",new a(Float32Array.from([0,0,0,1,1,0,1,1]),2)),this.groundPlane.rotateX(-Math.PI/2),this.scene.add(this.groundPlane)}loadMesh(e){this.onMeshLoad=e,this.input.click()}initMatcap(){this.matcapTextures={r:void 0,g:void 0,b:void 0,k:void 0},this.matcapTextures.r=(new r).load(this.geopticPath+"/img/clay_r.png"),this.matcapTextures.g=(new r).load(this.geopticPath+"/img/clay_g.png"),this.matcapTextures.b=(new r).load(this.geopticPath+"/img/clay_b.png"),this.matcapTextures.k=(new r).load(this.geopticPath+"/img/clay_k.png")}initRenderer(e){this.renderer=new f({antialias:!0}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setClearColor(16777215,1),this.renderer.setSize(this.parent.offsetWidth,this.parent.offsetHeight),this.container.appendChild(this.renderer.domElement),this.doPicks&&(this.pickRenderer=new f({antialias:!1}),this.pickRenderer.setPixelRatio(window.devicePixelRatio),this.pickRenderer.setClearColor(16777215,1),this.pickRenderer.setSize(this.parent.offsetWidth,this.parent.offsetHeight),e.appendChild(this.pickRenderer.domElement))}initGUI(){this.structureGui=new V({autoPlace:!1,resizeable:!0});let e=document.createElement("div");this.parent.appendChild(e),e.id="structure-gui",e.appendChild(this.structureGui.domElement),this.geopticOptions=this.structureGui.addFolder("Geoptic"),this.geopticOptions.open(),this.structureGuiFields["GroundPlane#Enabled"]=!0,this.geopticOptions.add(this.structureGuiFields,"GroundPlane#Enabled").onChange((e=>{e?this.scene.add(this.groundPlane):this.scene.remove(this.groundPlane)})).listen().name("Ground Plane")}initCamera(){const e=this.parent.offsetWidth/this.parent.offsetHeight;this.camera=new y(45,e,.01,1e3),this.camera.position.z=3.5}initScene(){this.scene=new x,this.scene.background=new b(16777215),this.doPicks&&(this.pickScene=new x,this.pickScene.background=new b(16777215))}initLights(){let e=new C(16777215,.35);this.camera.add(e);let t=new M(16777215);t.position.set(2,20,15),this.camera.add(t),this.scene.add(this.camera)}registerSurfaceMesh(e,t,i,s=1){t=Z(t),i=J(i),this.structureGuiMeshes||(this.structureGuiMeshes=this.structureGui.addFolder("Surface Meshes"),this.structureGuiMeshes.open());const n={};this.surfaceMeshes[e]&&(n.color=this.surfaceMeshes[e].getColor(),this.deregisterSurfaceMesh(e));let a=new K(t,i,e,this,n);this.surfaceMeshes[e]=a;let r=this.structureGuiMeshes.addFolder(e);a.initGui(this.structureGuiFields,r),this.scene.add(a.mesh),this.doPicks&&this.pickScene.add(a.pickMesh);let o=(new w).setFromObject(a.mesh);this.sceneMin.min(o.min),this.sceneMax.max(o.max);let l=this.groundPlane.position;return this.groundPlane.translateZ(this.sceneMin.y-l.y,1),a}registerCurveNetwork(e,t,i){if(t=Z(t),this.structureGuiCurveNetworks?i=J(i):(this.structureGuiCurveNetworks=this.structureGui.addFolder("Curve Networks"),this.structureGuiCurveNetworks.open()),!i){i=[];for(let e=0;e+1<t.length;e++)i.push([e,e+1])}let s=t.length;const n={};this.curveNetworks[e]&&(n.color=this.curveNetworks[e].getColor(),this.deregisterCurveNetwork(e));let a=new te(t,i,s,e,this,n);this.curveNetworks[e]=a;let r=this.structureGuiCurveNetworks.addFolder(e);return a.initGui(this.structureGuiFields,r),this.scene.add(a.mesh),a}registerPointCloud(e,t){t=Z(t),this.structureGuiPointClouds||(this.structureGuiPointClouds=this.structureGui.addFolder("Point Clouds"),this.structureGuiPointClouds.open());const i={};this.pointClouds[e]&&(i.color=this.pointClouds[e].getColor(),this.deregisterPointCloud(e));let s=new ee(t,e,this,i);this.pointClouds[e]=s;let n=this.structureGuiPointClouds.addFolder(e);return s.initGui(this.structureGuiFields,n),this.scene.add(s.mesh),this.doPicks&&this.pickScene.add(s.pickMesh),s}deregisterSurfaceMesh(e){e in this.surfaceMeshes&&(this.structureGuiMeshes.removeFolder(e),this.surfaceMeshes[e].remove(),this.scene.remove(this.surfaceMeshes[e].mesh),delete this.surfaceMeshes[e])}deregisterCurveNetwork(e){e in this.curveNetworks&&(this.structureGuiCurveNetworks.removeFolder(e),this.curveNetworks[e].remove(),this.scene.remove(this.curveNetworks[e].mesh),delete this.curveNetworks[e])}deregisterPointCloud(e){e in this.pointClouds&&(this.structureGuiPointClouds.removeFolder(e),this.pointClouds[e].remove(),this.scene.remove(this.pointClouds[e].mesh),delete this.pointClouds[e])}clearAllStructures(){let e=Object.keys(this.surfaceMeshes);e.forEach((e=>{this.deregisterSurfaceMesh(e)})),e=Object.keys(this.curveNetworks),e.forEach((e=>{this.deregisterCurveNetwork(e)}))}initControls(){this.controls=new F(this.camera,this.renderer.domElement),this.controls.rotateSpeed=5}clearDataFields(){document.getElementById("info-body-field-names").innerHTML="",document.getElementById("info-body-field-values").innerHTML=""}showDataField(e,t){let i=document.createElement("div");i.innerHTML=e,document.getElementById("info-body-field-names").appendChild(i);let s=document.createElement("div");s.innerHTML=t,document.getElementById("info-body-field-values").appendChild(s)}setDataHeader(e,t){document.getElementById("info-head-structure").innerHTML=e,document.getElementById("info-head-name").innerHTML=t}pick(e,t){const i=this.parent.getBoundingClientRect(),s=R(this.pickRenderer,this.pickScene,this.camera,e-i.left,t-i.top,i.width,i.height);s.structure&&s.structure.pickElement(s.localInd)}addEventListeners(){window.addEventListener("resize",this.onWindowResize.bind(this),!1),this.doPicks&&this.renderer.domElement.addEventListener("click",this.onMouseClick.bind(this),!1)}onWindowResize(){this.camera.aspect=this.parent.offsetWidth/this.parent.offsetHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(this.parent.offsetWidth,this.parent.offsetHeight),this.controls.handleResize(),this.render()}onMouseClick(e){e.clientX>=0&&e.clientX<=this.parent.offsetWidth&&e.clientY>=0&&e.clientY<=this.parent.offsetHeight&&this.pick(e.clientX,e.clientY)}animate(){requestAnimationFrame(function(){this.animate()}.bind(this)),this.userCallback(),this.controls&&this.controls.update(),this.render(),this.stats.update()}render(){let e=this.parent.offsetWidth;this.renderer.setViewport(0,0,e,this.parent.offsetHeight),this.renderer.setScissor(0,0,e,this.parent.offsetHeight),this.renderer.setScissorTest(!0),this.renderer.render(this.scene,this.camera)}message(e){let t=document.createElement("div"),i=document.getElementById("messages");i.insertBefore(t,i.firstChild),t.innerHTML=e}startLoading(){console.log("start loading!"),document.getElementById("spinner").style.display="inline-block"}doneLoading(){document.getElementById("spinner").style.display="none"}slowFunction(e){this.startLoading(),setTimeout(function(){e(),this.doneLoading()}.bind(this),1)}prettyScalar(e){return e.toFixed(5)}prettyVector2(e){return e.x?"("+e.x.toFixed(2)+", "+e.y.toFixed(2)+")":"("+e[0].toFixed(2)+", "+e[1].toFixed(2)+")"}prettyVector(e){return e.x?"("+e.x.toFixed(2)+", "+e.y.toFixed(2)+", "+e.z.toFixed(2)+")":"("+e[0].toFixed(2)+", "+e[1].toFixed(2)+", "+e[2].toFixed(2)+")"}listToVec(e){return new t(e[0],e[1],e[2])}}export{ie as Geoptic};
