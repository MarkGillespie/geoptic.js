!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("https://unpkg.com/three@0.125.1/build/three.module.js"),require("https://unpkg.com/three@0.125.1/examples/jsm/controls/TrackballControls.js"),require("https://unpkg.com/three@0.125.1/examples/jsm/WebGL.js"),require("https://unpkg.com/three@0.125.1/examples/jsm/objects/Reflector.js"),require("https://unpkg.com/three@0.125.1/examples/jsm/loaders/RGBELoader.js"),require("https://unpkg.com/three@0.125.1/examples/jsm/libs/stats.module.js"),require("https://unpkg.com/dat.gui@0.7.6/build/dat.gui.module.js")):"function"==typeof define&&define.amd?define(["exports","https://unpkg.com/three@0.125.1/build/three.module.js","https://unpkg.com/three@0.125.1/examples/jsm/controls/TrackballControls.js","https://unpkg.com/three@0.125.1/examples/jsm/WebGL.js","https://unpkg.com/three@0.125.1/examples/jsm/objects/Reflector.js","https://unpkg.com/three@0.125.1/examples/jsm/loaders/RGBELoader.js","https://unpkg.com/three@0.125.1/examples/jsm/libs/stats.module.js","https://unpkg.com/dat.gui@0.7.6/build/dat.gui.module.js"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).geoptic={},e.THREE,e.TrackballControls_js,e.WebGL_js,e.Reflector_js,null,e.Stats,e.dat_gui_module_js)}(this,(function(e,t,i,s,n,a,r,o){"use strict";function l(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var h=l(r);let d="\n        uniform sampler2D Matcap_r; // Matcap texture\n        uniform sampler2D Matcap_g; // Matcap texture\n        uniform sampler2D Matcap_b; // Matcap texture\n        uniform sampler2D Matcap_k; // Matcap texture\n",c="\n        float getEdgeFactor(vec3 UVW, vec3 edgeReal, float width) {\n\n            // The Nick Sharp Edge Function (tm). There are many like it, but this one is his.\n            float slopeWidth = 1.;\n\n            vec3 fw = fwidth(UVW);\n            vec3 realUVW = max(UVW, 1. - edgeReal.yzx);\n            vec3 baryWidth = slopeWidth * fw;\n\n            vec3 end = width * fw;\n            vec3 dist = smoothstep(end - baryWidth, end, realUVW);\n\n            float e = 1.0 - min(min(dist.x, dist.y), dist.z);\n            return e;\n        }\n\n        vec4 lightSurfaceMat(vec3 color, vec2 Normal) {\n            vec4 mat_r = sRGBToLinear(texture2D(Matcap_r, Normal));\n            vec4 mat_g = sRGBToLinear(texture2D(Matcap_g, Normal));\n            vec4 mat_b = sRGBToLinear(texture2D(Matcap_b, Normal));\n            vec4 mat_k = sRGBToLinear(texture2D(Matcap_k, Normal));\n\n            vec4 colorCombined = color.r * mat_r + color.g * mat_g + color.b * mat_b +\n                                (1. - color.r - color.g - color.b) * mat_k;\n\n            return LinearTosRGB( colorCombined );\n        }\n";function u(e,i,s,n){let a=`\n        ${d}\n        uniform vec3 edgeColor;\n        uniform float edgeWidth;\n        uniform vec3 color1;\n        uniform vec3 color2;\n        uniform float paramScale;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying vec2 Coord;\n\n        ${c}\n\n        void main(void){\n            float alpha = getEdgeFactor(Barycoord, vec3(1.,1.,1.), edgeWidth);\n\n            // Apply the checkerboard effect\n            float mX = mod(Coord.x, 2.0 * paramScale) / paramScale - 1.f; // in [-1, 1]\n            float mY = mod(Coord.y, 2.0 * paramScale) / paramScale - 1.f;\n\n            float minD = min( min(abs(mX), 1.0 - abs(mX)), min(abs(mY), 1.0 - abs(mY))) * 2.; // rect distace from flipping sign in [0,1]\n            float p = 6.;\n            float minDSmooth = pow(minD, 1. / p);\n            // TODO do some clever screen space derivative thing to prevent aliasing\n\n            float v = (mX * mY); // in [-1, 1], color switches at 0\n            float adjV = sign(v) * minDSmooth;\n\n            float s = smoothstep(-1.f, 1.f, adjV);\n\n            vec3 outColor = (1.-s)*color1 + s* color2;\n\n            gl_FragColor = lightSurfaceMat((1.-alpha) * outColor + alpha * edgeColor, Point);\n\n        }\n    `,r=new t.ShaderMaterial({uniforms:{Matcap_r:{value:e},Matcap_g:{value:i},Matcap_b:{value:s},Matcap_k:{value:n},edgeColor:{value:new t.Vector3(0,0,0)},edgeWidth:{value:0},color1:{value:new t.Vector3(1,1,0)},color2:{value:new t.Vector3(0,1,1)},paramScale:{value:1}},vertexShader:"\n        attribute vec3 barycoord;\n        attribute vec2 coord;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying vec2 Coord;\n\n        void main()\n        {\n            vec3 vNormal = ( mat3( modelViewMatrix ) * normal );\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Barycoord = barycoord;\n            Coord = coord;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:a});return r.side=t.DoubleSide,r}function m(e,i,s,n){let a=`\n        ${d}\n        uniform vec3 color;\n\n        varying vec2 Point;\n\n        ${c}\n\n        void main(void){\n            gl_FragColor = lightSurfaceMat(color, Point);\n        }\n    `,r=new t.ShaderMaterial({uniforms:{Matcap_r:{value:e},Matcap_g:{value:i},Matcap_b:{value:s},Matcap_k:{value:n},color:{value:new t.Vector3(1,0,1)},scale:{value:1}},vertexShader:"\n        uniform float scale;\n        varying vec2 Point;\n\n        void main()\n        {\n            vec3 vNormal = (modelViewMatrix * instanceMatrix * vec4(normal, 0.)).xyz;\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( scale * position, 1.0 );\n\n        }\n    ",fragmentShader:a});return r.side=t.DoubleSide,r}let p=1,g=[],v=new t.WebGLRenderTarget;function f(e,t){let i=p,s=p+t;return g.push({start:i,end:s,structure:e}),p=s,i}function y(e,t,i,s,n,a,r){v.setSize(a,r),e.setRenderTarget(v),e.render(t,i);let o=new Uint8Array(4);return e.readRenderTargetPixels(v,s,v.height-n,1,1,o),function(e){for(let t of g)if(e>=t.start&&e<t.end)return{localInd:e-t.start,structure:t.structure};return{localInd:0,structure:void 0}}(o[0]+256*o[1]+256*o[2]*256)}function b(e){return[((255&e)>>0)/255,((65280&e)>>8)/255,((16711680&e)>>16)/255]}function x(e,t){if(t<0)return 0;let i=0,s=.5;for(;t>0;)t%2==1&&(i+=s),t/=2,s/=2;return i=(i+e)%1,n=i,Math.max(0,Math.min(1,n));var n}function C(e,t){return function(e,t,i){let s,n,a,r=Math.floor(6*e),o=6*e-r,l=i*(1-t),h=i*(1-o*t),d=i*(1-(1-o)*t);switch(r%6){case 0:s=i,n=d,a=l;break;case 1:s=h,n=i,a=l;break;case 2:s=l,n=i,a=d;break;case 3:s=l,n=h,a=i;break;case 4:s=d,n=l,a=i;break;case 5:s=i,n=l,a=h}return[255*s,255*n,255*a]}(x(e[0],t),e[1],e[2])}v.texture.generateMipmaps=!1;let M=[219/360,.88,.89],w=0;function k(){return C(M,w++)}const F=["viridis","plasma","magma","inferno","coolwarm","blues","piyg","spectral","rainbow","jet","reds","hsv","rdpu"];function E(e){let t=e[0],i=e[0];return e.forEach((e=>{t=Math.min(t,e),i=Math.max(i,e)})),[t,i]}class V{constructor(e,i,s){this.parent=s,this.gp=this.parent.gp,this.values=i,this.name=e,this.enabled=!1,this.isDominantQuantity=!0,[this.dataMin,this.dataMax]=E(i);let n=function(e,i,s,n){let a=`\n        ${d}\n        uniform sampler2D colormap; // colormap\n        uniform vec3 edgeColor;\n        uniform float edgeWidth;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying float Value;\n\n        ${c}\n\n        void main(void){\n            float alpha = getEdgeFactor(Barycoord, vec3(1.,1.,1.), edgeWidth);\n            vec3 Color = sRGBToLinear(texture2D(colormap, vec2(Value, 0.5))).rgb;\n            gl_FragColor = lightSurfaceMat((1.-alpha) * Color + alpha * edgeColor, Point);\n        }\n    `,r=new t.ShaderMaterial({uniforms:{Matcap_r:{value:e},Matcap_g:{value:i},Matcap_b:{value:s},Matcap_k:{value:n},colormap:{value:void 0},edgeColor:{value:new t.Vector3(0,0,0)},edgeWidth:{value:0}},vertexShader:"\n        attribute vec3 barycoord;\n        attribute float value;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying float Value;\n\n        void main()\n        {\n            vec3 vNormal = ( mat3( modelViewMatrix ) * normal );\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Barycoord = barycoord;\n            Value = value;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:a});return r.side=t.DoubleSide,r}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);this.mesh=new t.Mesh(this.parent.mesh.geometry.clone(),n),this.initializeFunctionValues(),this.mesh.geometry.attributes.position=this.parent.mesh.geometry.attributes.position,this.mesh.geometry.attributes.normal=this.parent.mesh.geometry.attributes.normal,this.mesh.material.uniforms.edgeWidth=this.parent.mesh.material.uniforms.edgeWidth,this.mesh.material.uniforms.edgeColor=this.parent.mesh.material.uniforms.edgeColor}initGui(e,t){this.prefix=this.parent.name+"#"+this.name,this.guiFields=e,e[this.prefix+"#Enabled"]=!1,t.add(e,this.prefix+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.prefix+"#ColorMap"]="viridis",this.applyColorMap(e[this.prefix+"#ColorMap"]),t.add(e,this.prefix+"#ColorMap",F).onChange((e=>{this.applyColorMap(e)})).listen().name("Color Map")}setEnabled(e){this.guiFields[this.prefix+"#Enabled"]=e,this.enabled=e,e?this.parent.enableQuantity(this):this.parent.disableQuantity(this)}setColorMap(e){this.guiFields[this.prefix+"#ColorMap"]=e,this.applyColorMap(e)}initializeFunctionValues(){let e=this.parent.faces.length,i=new Float32Array(3*e);for(let t=0;t<e;t++){let e=this.parent.faces[t];for(let s=0;s<3;s++){let n=this.values[e[s]];n=(n-this.dataMin)/(this.dataMax-this.dataMin),i[3*t+s]=n}}this.mesh.geometry.setAttribute("value",new t.BufferAttribute(i,1))}applyColorMap(e){this.mesh.material.uniforms.colormap.value=(new t.TextureLoader).load(this.gp.geopticPath+"/img/colormaps/"+e+".png")}getVertexValue(e){return this.gp.prettyScalar(this.values[e])}getEdgeValue(e){}getFaceValue(e){}remove(){}}class P{constructor(e,i,s){this.parent=s,this.gp=this.parent.gp,this.values=i,this.name=e,this.enabled=!1,this.isDominantQuantity=!0,[this.dataMin,this.dataMax]=E(i);let n=function(e,i,s,n){let a=`\n        ${d}\n        uniform sampler2D colormap; // colormap\n\n        varying float Value;\n        varying vec2 Point;\n\n        ${c}\n\n        void main(void){\n            vec3 Color = sRGBToLinear(texture2D(colormap, vec2(Value, 0.5))).rgb;\n            gl_FragColor = lightSurfaceMat(Color, Point);\n        }\n    `,r=new t.ShaderMaterial({uniforms:{Matcap_r:{value:e},Matcap_g:{value:i},Matcap_b:{value:s},Matcap_k:{value:n},colormap:{value:void 0},scale:{value:1}},vertexShader:"\n        uniform float scale;\n        attribute float value;\n\n        varying float Value;\n        varying vec2 Point;\n\n        void main()\n        {\n            vec3 vNormal = (modelViewMatrix * instanceMatrix * vec4(normal, 0.)).xyz;\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Value = value;\n\n            gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( scale * position, 1.0 );\n\n        }\n    ",fragmentShader:a});return r.side=t.DoubleSide,r}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);this.mesh=new t.InstancedMesh(this.parent.mesh.geometry.clone(),n,this.parent.nV),this.mesh.geometry.attributes.position=this.parent.mesh.geometry.attributes.position,this.mesh.geometry.attributes.normal=this.parent.mesh.geometry.attributes.normal,this.mesh.material.uniforms.scale=this.parent.mesh.material.uniforms.scale,this.mesh.instanceMatrix=this.parent.mesh.instanceMatrix,this.initializeFunctionValues()}initGui(e,t){this.prefix=this.parent.name+"#"+this.name,this.guiFields=e,e[this.prefix+"#Enabled"]=!1,t.add(e,this.prefix+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.prefix+"#ColorMap"]="viridis",this.applyColorMap(e[this.prefix+"#ColorMap"]),t.add(e,this.prefix+"#ColorMap",F).onChange((e=>{this.applyColorMap(e)})).listen().name("Color Map")}setEnabled(e){this.guiFields[this.prefix+"#Enabled"]=e,this.enabled=e,e?this.parent.enableQuantity(this):this.parent.disableQuantity(this)}initializeFunctionValues(){let e=new Float32Array(3*this.parent.nV);for(let t=0;t<this.parent.nV;t++){let i=this.values[t];i=(i-this.dataMin)/(this.dataMax-this.dataMin),e[t]=i}this.mesh.geometry.setAttribute("value",new t.InstancedBufferAttribute(e,1))}applyColorMap(e){this.mesh.material.uniforms.colormap.value=(new t.TextureLoader).load(this.gp.geopticPath+"/img/colormaps/"+e+".png")}getVertexValue(e){return this.values[e]}getEdgeValue(e){}getFaceValue(e){}remove(){}}class S{constructor(e,i,s){this.parent=s,this.gp=this.parent.gp,this.values=i,this.name=e,this.enabled=!1,this.isDominantQuantity=!0,[this.dataMin,this.dataMax]=function(e){let t=e[0],i=e[0];return e.forEach((e=>{t=Math.min(t,e),i=Math.max(i,e)})),[t,i]}(i);let n=function(e,i,s,n){let a=`\n        ${d}\n        uniform sampler2D colormap; // colormap\n        uniform vec3 edgeColor;\n        uniform float edgeWidth;\n        uniform float scale;\n        uniform float offset;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying float Value;\n\n        ${c}\n\n        void main(void){\n            float v1 = Value * (1.-offset);\n            float v2 = Value * (1.-offset) + offset;\n\n            vec3 color1 = sRGBToLinear(texture2D(colormap, vec2(v1, 0.5))).rgb;\n            vec3 color2 = sRGBToLinear(texture2D(colormap, vec2(v2, 0.5))).rgb;\n\n            // Apply the stripe effect\n            float mX = mod(Value * 2.*scale, 2.)  - 1.f; // in [-1, 1]\n\n            float p = 6.;\n            float minDSmooth = pow(mX, 1. / p);\n            // TODO do some clever screen space derivative thing to prevent aliasing\n\n            float adjV = sign(mX) * minDSmooth;\n\n            float s = smoothstep(-1.f, 1.f, adjV);\n\n            vec3 outColor = (1.-s)*color1 + s* color2;\n\n            float alpha = getEdgeFactor(Barycoord, vec3(1.,1.,1.), edgeWidth);\n            gl_FragColor = lightSurfaceMat((1.-alpha) * outColor + alpha * edgeColor, Point);\n        }\n    `,r=new t.ShaderMaterial({uniforms:{Matcap_r:{value:e},Matcap_g:{value:i},Matcap_b:{value:s},Matcap_k:{value:n},colormap:{value:void 0},edgeColor:{value:new t.Vector3(0,0,0)},edgeWidth:{value:0},scale:{value:1},offset:{value:.2}},vertexShader:"\n        attribute vec3 barycoord;\n        attribute float value;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying float Value;\n\n        void main()\n        {\n            vec3 vNormal = ( mat3( modelViewMatrix ) * normal );\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Barycoord = barycoord;\n            Value = value;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:a});return r.side=t.DoubleSide,r}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);this.mesh=new t.Mesh(this.parent.mesh.geometry.clone(),n),this.mesh.material.uniforms.colormap.value=(new t.TextureLoader).load(this.gp.geopticPath+"/img/colormaps/RdPu.png"),this.initializeDistances(this.values),this.mesh.geometry.attributes.position=this.parent.mesh.geometry.attributes.position,this.mesh.geometry.attributes.normal=this.parent.mesh.geometry.attributes.normal,this.mesh.material.uniforms.edgeWidth=this.parent.mesh.material.uniforms.edgeWidth,this.mesh.material.uniforms.edgeColor=this.parent.mesh.material.uniforms.edgeColor}initGui(e,t){this.prefix=this.parent.name+"#"+this.name,this.guiFields=e,e[this.prefix+"#Enabled"]=!1,t.add(e,this.prefix+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.name+"#Stripes"]=20,this.setStripes(e[this.name+"#Stripes"]),t.add(e,this.name+"#Stripes").min(0).max(50).step(.5).onChange((e=>{this.setStripes(e)})).listen().name("Stripes"),e[this.name+"#Offset"]=.2,this.setOffset(e[this.name+"#Offset"]),t.add(e,this.name+"#Offset").min(0).max(.5).step(.05).onChange((e=>{this.setOffset(e)})).listen().name("Offset"),e[this.prefix+"#ColorMap"]="rdpu",this.applyColorMap(e[this.prefix+"#ColorMap"]),t.add(e,this.prefix+"#ColorMap",F).onChange((e=>{this.applyColorMap(e)})).listen().name("Color Map")}setEnabled(e){this.guiFields[this.prefix+"#Enabled"]=e,this.enabled=e,e?this.parent.enableQuantity(this):this.parent.disableQuantity(this)}setColorMap(e){this.guiFields[this.prefix+"#ColorMap"]=e,this.applyColorMap(e)}setStripes(e){this.mesh.material.uniforms.scale.value=e}setOffset(e){this.mesh.material.uniforms.offset.value=e}initializeDistances(e){let i=this.parent.faces.length,s=new Float32Array(3*i);for(let e=0;e<i;e++){let t=this.parent.faces[e];for(let i=0;i<3;i++){let n=this.values[t[i]];n=(n-this.dataMin)/(this.dataMax-this.dataMin),s[3*e+i]=n}}this.mesh.geometry.setAttribute("value",new t.BufferAttribute(s,1))}applyColorMap(e){this.mesh.material.uniforms.colormap.value=(new t.TextureLoader).load(this.gp.geopticPath+"/img/colormaps/"+e+".png")}getVertexValue(e){return this.gp.prettyScalar(this.values[e])}getEdgeValue(e){}getFaceValue(e){}remove(){}}class T{constructor(e,t,i){this.parent=i,this.gp=this.parent.gp,this.values=t,this.name=e,this.enabled=!1,this.res=4,this.rad=.5,this.len=3,this.tipFrac=.3,this.widthFrac=.5,this.isDominantQuantity=!1,this.mesh=this.constructArrowMesh(this.parent.coords,t)}constructArrowMesh(e,i){let s=new t.CylinderGeometry(this.rad*this.widthFrac,this.rad*this.widthFrac,this.len*(1-this.tipFrac),this.res),n=s.attributes.position.array,a=s.attributes.position.count,r=-this.len*(1-this.tipFrac)/2;for(let e=0;e<a;e++)n[3*e+1]=n[3*e+1]-r;let o=new t.CylinderGeometry(0,this.rad,this.len*this.tipFrac,this.res);n=o.attributes.position.array,a=o.attributes.position.count,r=-this.len*this.tipFrac/2;for(let e=0;e<a;e++)n[3*e+1]=n[3*e+1]-r+this.len*(1-this.tipFrac);let l=new t.Matrix4;l.set(0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,1),s.applyMatrix4(l),o.applyMatrix4(l);let h=m(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);h.uniforms.scale.value=.05;let d=this.parent.nV;this.torsoMesh=new t.InstancedMesh(s,h,d),this.tipMesh=new t.InstancedMesh(o,h,d),l=new t.Matrix4;for(let e=0;e<d;e++){let s=this.parent.coords.get(e),n=i.get(e);l.lookAt(n,new t.Vector3(0,0,0),new t.Vector3(0,0,1)),l.setPosition(s[0],s[1],s[2]),this.torsoMesh.setMatrixAt(e,l),this.tipMesh.setMatrixAt(e,l)}let c=new t.Group;return c.add(this.torsoMesh),c.add(this.tipMesh),c}initGui(e,t){this.prefix=this.parent.name+"#"+this.name,this.guiFields=e,e[this.prefix+"#Enabled"]=!1,t.add(e,this.prefix+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.name+"#Color"]=k(),this.setColor(e[this.name+"#Color"]),t.addColor(e,this.name+"#Color").onChange((e=>{this.setColor(e)})).listen().name("Color"),e[this.name+"#Radius"]=1,this.setRadius(e[this.name+"#Radius"]),t.add(e,this.name+"#Radius").min(0).max(5).step(.05).onChange((e=>{this.setRadius(e)})).listen().name("Radius")}setColor(e){let i=new t.Vector3(e[0]/255,e[1]/255,e[2]/255);this.torsoMesh.material.uniforms.color.value=i,this.tipMesh.material.uniforms.color.value=i}setRadius(e){this.torsoMesh.material.uniforms.scale.value=.05*e,this.tipMesh.material.uniforms.scale.value=.05*e}setEnabled(e){this.guiFields[this.prefix+"#Enabled"]=e,this.enabled=e,e?this.parent.enableQuantity(this):this.parent.disableQuantity(this)}getVertexValue(e){let t=this.values.get(e),i=[t.x,t.y,t.z];return this.gp.prettyVector(i)}getEdgeValue(e){}getFaceValue(e){}}class _{constructor(e,i,s){this.parent=s,this.gp=this.parent.gp,this.coords=i,this.name=e,this.enabled=!1,this.isDominantQuantity=!0;let n=u(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);this.mesh=new t.Mesh(this.parent.mesh.geometry.clone(),n),this.initParam(i),this.mesh.geometry.attributes.position=this.parent.mesh.geometry.attributes.position,this.mesh.geometry.attributes.normal=this.parent.mesh.geometry.attributes.normal,this.mesh.material.uniforms.edgeWidth=this.parent.mesh.material.uniforms.edgeWidth,this.mesh.material.uniforms.edgeColor=this.parent.mesh.material.uniforms.edgeColor}initGui(e,t){this.prefix=this.parent.name+"#"+this.name,this.guiFields=e,e[this.prefix+"#Enabled"]=!1,t.add(e,this.prefix+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.prefix+"#Style"]="checker",t.add(e,this.prefix+"#Style",["checker","grid"]).onChange((e=>{this.applyStyle(e)})).listen().name("Color Map"),e[this.name+"#Color1"]=[249,45,94],this.setColor1(e[this.name+"#Color1"]),t.addColor(e,this.name+"#Color1").onChange((e=>{this.setColor1(e)})).listen().name("Color"),e[this.name+"#Color2"]=[249,219,225],this.setColor2(e[this.name+"#Color2"]),t.addColor(e,this.name+"#Color2").onChange((e=>{this.setColor2(e)})).listen().name("Color"),e[this.name+"#Scale"]=1,this.setScale(e[this.name+"#Scale"]),t.add(e,this.name+"#Scale").min(0).max(2).step(.05).onChange((e=>{this.setScale(e)})).listen().name("Scale")}setScale(e){this.mesh.material.uniforms.paramScale.value=e/10}setColor1(e){let i=new t.Vector3(e[0]/255,e[1]/255,e[2]/255);this.mesh.material.uniforms.color1.value=i}setColor2(e){let i=new t.Vector3(e[0]/255,e[1]/255,e[2]/255);this.mesh.material.uniforms.color2.value=i}setEnabled(e){this.guiFields[this.prefix+"#Enabled"]=e,this.enabled=e,e?this.parent.enableQuantity(this):this.parent.disableQuantity(this)}applyStyle(e){"checker"==e?this.mesh.material=u(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k):"grid"==e&&(this.mesh.material=function(e,i,s,n){let a=`\n        ${d}\n        uniform vec3 edgeColor;\n        uniform float edgeWidth;\n        uniform vec3 color1;\n        uniform vec3 color2;\n        uniform float paramScale;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying vec2 Coord;\n\n        ${c}\n\n        void main(void){\n            float alpha = getEdgeFactor(Barycoord, vec3(1.,1.,1.), edgeWidth);\n\n\n            // Apply the checkerboard effect\n            float mX = mod(Coord.x, 2.0 * paramScale) / paramScale - 1.f; // in [-1, 1]\n            float mY = mod(Coord.y, 2.0 * paramScale) / paramScale - 1.f;\n\n\n            // rect distace from flipping sign in [0,1]\n            float minD = min(min(abs(mX), 1.0 - abs(mX)), min(abs(mY), 1.0 - abs(mY))) * 2.;\n\n            float width = 0.05;\n            float slopeWidthPix = 10.;\n\n            vec2 fw = fwidth(Coord);\n            float scale = max(fw.x, fw.y);\n            float pWidth = slopeWidthPix * scale;\n\n            float s = smoothstep(width, width + pWidth, minD);\n\n            vec3 outColor = (1.-s)*color1 + s* color2;\n\n            gl_FragColor = lightSurfaceMat((1.-alpha) * outColor + alpha * edgeColor, Point);\n\n        }\n    `,r=new t.ShaderMaterial({uniforms:{Matcap_r:{value:e},Matcap_g:{value:i},Matcap_b:{value:s},Matcap_k:{value:n},edgeColor:{value:new t.Vector3(0,0,0)},edgeWidth:{value:0},color1:{value:new t.Vector3(1,1,0)},color2:{value:new t.Vector3(0,1,1)},paramScale:{value:1}},vertexShader:"\n        attribute vec3 barycoord;\n        attribute vec2 coord;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n        varying vec2 Coord;\n\n        void main()\n        {\n            vec3 vNormal = ( mat3( modelViewMatrix ) * normal );\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Barycoord = barycoord;\n            Coord = coord;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:a});return r.side=t.DoubleSide,r}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k)),this.setColor1(this.guiFields[this.name+"#Color1"]),this.setColor2(this.guiFields[this.name+"#Color2"]),this.setScale(this.guiFields[this.name+"#Scale"]),this.mesh.material.uniforms.edgeWidth=this.parent.mesh.material.uniforms.edgeWidth,this.mesh.material.uniforms.edgeColor=this.parent.mesh.material.uniforms.edgeColor}initParam(e){let i=this.parent.faces.length,s=new Float32Array(3*i*2);for(let t=0;t<i;t++){let i=this.parent.faces[t];for(let n=0;n<3;n++){let a=e[i[n]];for(let e=0;e<2;++e)s[6*t+2*n+e]=a[e]}}this.mesh.geometry.setAttribute("coord",new t.BufferAttribute(s,2))}getVertexValue(e){return this.gp.prettyVector2(this.coords[e])}getEdgeValue(e){}getFaceValue(e){}remove(){}}function G(e){let t,i,s;t=e.get?t=>e.get(t):t=>e[t],i=t(0).x?function(e,t){return 0==t?e.x:1==t?e.y:e.z}:(e,t)=>e[t],s=e.size?e.size():e.length;const n=[];let a;for(let e=0;e<s;e++)a=t(e),n.push([i(a,0),i(a,1),i(a,2)]);return n}function A(e){let t,i,s=!1;e.get?"number"==typeof e.get(0)||"bigint"==typeof e.get(0)?(s=!0,t=t=>[e.get(3*t),e.get(3*t+1),e.get(3*t+2)]):t=e.get(0).get?t=>[e.get(t).get(0),e.get(t).get(1),e.get(t).get(2)]:t=>e.get(t):"number"==typeof e[0]||"bigint"==typeof e[0]?(s=!0,t=t=>[e[3*t],e[3*t+1],e[3*t+2]]):t=t=>e[t],i=e.size?e.size():e.length,s&&(i/=3);const n=[];for(let e=0;e<i;e++)n.push([t(e)[0],t(e)[1],t(e)[2]]);return n}class B{constructor(e,t,i,s,n={}){this.gp=s,this.nV=e.length,this.coords=e,this.faces=t,this.name=i,this.enabled=!0,this.color=n.color||k(),[this.mesh,this.geo]=this.constructThreeMesh(e,t),[this.smoothVertexNormals,this.smoothCornerNormals]=this.computeSmoothNormals(),this.gp.doPicks&&(this.pickMesh=this.constructThreePickMesh(e,t)),this.quantities={},this.setSmoothShading(!0),this.guiFields=void 0,this.guiFolder=void 0,this.vertexPickCallback=e=>{},this.edgePickCallback=e=>{},this.facePickCallback=e=>{}}addVertexScalarQuantity(e,t){this.quantities[e]=new V(e,t,this),this.guiFolder.removeFolder(e);let i=this.guiFolder.addFolder(e);return this.quantities[e].initGui(this.guiFields,i),this.quantities[e]}addVertexDistanceQuantity(e,t){this.quantities[e]=new S(e,t,this),this.guiFolder.removeFolder(e);let i=this.guiFolder.addFolder(e);return this.quantities[e].initGui(this.guiFields,i),this.quantities[e]}addVertexVectorQuantity(e,t){t=G(t),this.quantities[e]=new T(e,t,this),this.guiFolder.removeFolder(e);let i=this.guiFolder.addFolder(e);return this.quantities[e].initGui(this.guiFields,i),this.quantities[e]}addVertexParameterizationQuantity(e,t){t=function(e){let t,i,s;t=e.get?t=>e.get(t):t=>e[t],i=t(0).x?function(e,t){return 0==t?e.x:e.y}:(e,t)=>e[t],s=e.size?e.size():e.length;const n=[];let a;for(let e=0;e<s;e++)a=t(e),n.push([i(a,0),i(a,1)]);return n}(t),this.quantities[e]=new _(e,t,this),this.guiFolder.removeFolder(e);let i=this.guiFolder.addFolder(e);return this.quantities[e].initGui(this.guiFields,i),this.quantities[e]}initGui(e,t){this.guiFields=e,this.guiFolder=t;let i=t.domElement.firstChild,s=document.createElement("li");s.classList.add("dat-info-box"),i.appendChild(s);let n=document.createElement("span");n.innerHTML="#verts: "+this.nV;let a=document.createElement("span");a.innerHTML="   #faces: "+this.faces.length,s.appendChild(n),s.appendChild(a),e[this.name+"#Enabled"]=!0;let r=t.add(e,this.name+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled").domElement.closest("li");r.classList.add("half-button"),r.style.width="35%",e[this.name+"#Smooth"]=!0;r=t.add(e,this.name+"#Smooth").onChange((e=>{this.setSmoothShading(e)})).listen().name("Smooth").domElement.closest("li"),r.classList.add("half-button"),r.style.width="35%",e[this.name+"#Edges"]=!1;r=t.add(e,this.name+"#Edges").onChange((e=>{this.setEdgesEnabled(e)})).listen().name("Edges").domElement.closest("li"),r.classList.add("half-button"),r.style.width="30%",e[this.name+"#Color"]=this.color,this.setColor(e[this.name+"#Color"]),t.addColor(e,this.name+"#Color").onChange((e=>{this.setColor(e)})).listen().name("Color"),e[this.name+"#Edge Width"]=0,this.edgeWidth=1;r=t.add(e,this.name+"#Edge Width").min(0).max(2).step(.05).onChange((e=>{this.edgeWidth=e,this.mesh.material.uniforms.edgeWidth.value=e})).listen().name("Edge Width").domElement.closest("li"),r.style.display="none",this.edgeGuis=[r],e[this.name+"#Edge Color"]=[0,0,0];r=t.addColor(e,this.name+"#Edge Color").onChange((e=>{this.setEdgeColor(e)})).listen().name("Edge Color").domElement.closest("li"),r.style.display="none",this.edgeGuis.push(r),t.open()}setEdgesEnabled(e){this.guiFields[this.name+"#Edges"]=e;for(let t of this.edgeGuis)t.style.display=e?"block":"none";e?(this.mesh.material.uniforms.edgeWidth.value=this.edgeWidth,this.guiFields[this.name+"#Edge Width"]=this.edgeWidth):(this.mesh.material.uniforms.edgeWidth.value=0,this.guiFields[this.name+"#Edge Width"]=0)}setSmoothShading(e){e?this.mesh.geometry.attributes.normal.array=new Float32Array(this.smoothCornerNormals):this.mesh.geometry.computeVertexNormals(),this.mesh.geometry.attributes.normal.needsUpdate=!0}setColor(e){this.color=e;let i=new t.Vector3(e[0]/255,e[1]/255,e[2]/255);this.mesh.material.uniforms.color.value=i}getColor(){return this.color}setEdgeColor(e){let i=new t.Vector3(e[0]/255,e[1]/255,e[2]/255);this.mesh.material.uniforms.edgeColor.value=i}setEnabled(e){if(this.enabled=e,this.guiFields[this.name+"#Enabled"]=e,e){let e=!1;for(let t in this.quantities)this.quantities[t].enabled&&(this.gp.scene.add(this.quantities[t].mesh),e=!0);e||this.gp.scene.add(this.mesh),this.gp.doPicks&&this.gp.pickScene.add(this.pickMesh)}else{for(let e in this.quantities)this.gp.scene.remove(this.quantities[e].mesh);this.gp.scene.remove(this.mesh),this.gp.doPicks&&this.gp.pickScene.remove(this.pickMesh)}}enableQuantity(e){if(e.isDominantQuantity)for(let t in this.quantities){let i=this.quantities[t];i.isDominantQuantity&&t!=e.name&&(this.guiFields[i.prefix+"#Enabled"]=!1,i.enabled=!1,this.gp.scene.remove(i.mesh))}this.enabled&&(e.isDominantQuantity&&this.gp.scene.remove(this.mesh),this.gp.scene.add(e.mesh))}disableQuantity(e){this.enabled&&(this.gp.scene.remove(e.mesh),this.gp.scene.add(this.mesh))}remove(){for(let e in this.quantities)this.gp.scene.remove(this.quantities[e].mesh),this.quantities[e].remove();this.quantities={}}computeSmoothNormals(){let e=this.nV,i=this.faces.length,s=new Float32Array(3*e);for(let t=0;t<e;++t)s[3*t+0]=0,s[3*t+1]=0,s[3*t+2]=0;const n=this.mesh.geometry.attributes.normal.array;for(let e=0;e<i;e++){let t=this.faces[e];for(let i=0;i<3;i++){let a=t[i];for(let t=0;t<3;++t)s[3*a+t]+=n[9*e+3*i+t]}}for(let i=0;i<e;++i){let e=new t.Vector3(s[3*i+0],s[3*i+1],s[3*i+2]);e.normalize(),s[3*i+0]=e.x,s[3*i+1]=e.y,s[3*i+2]=e.z}let a=new Float32Array(3*i*3);for(let e=0;e<i;e++){let t=this.faces[e];for(let i=0;i<3;i++)for(let n=0;n<3;++n)a[9*e+3*i+n]=s[3*t[i]+n]}return[s,a]}setPosition(e){let i=new t.Euler(this.mesh.rotation.x,this.mesh.rotation.y,this.mesh.rotation.z);this.mesh.setRotationFromAxisAngle(new t.Vector3(1,0,0),0),this.gp.doPicks&&this.pickMesh.setRotationFromAxisAngle(new t.Vector3(1,0,0),0);let s=this.mesh.position;this.mesh.translateX(e.x-s.x,1),this.mesh.translateY(e.y-s.y,1),this.mesh.translateZ(e.z-s.z,1),this.gp.doPicks&&(s=this.pickMesh.position,this.pickMesh.translateX(e.x-s.x,1),this.pickMesh.translateY(e.y-s.y,1),this.pickMesh.translateZ(e.z-s.z,1)),this.mesh.setRotationFromEuler(i),this.gp.doPicks&&this.pickMesh.setRotationFromEuler(i)}setOrientationFromMatrix(e){this.mesh.setRotationFromAxisAngle(new t.Vector3(1,0,0),0),this.mesh.setRotationFromMatrix(e),this.gp.doPicks&&(this.pickMesh.setRotationFromAxisAngle(new t.Vector3(1,0,0),0),this.pickMesh.setRotationFromMatrix(e))}setOrientationFromFrame(e,i,s){let n=new t.Matrix4;n.set(-e.x,i.x,-s.x,0,-e.y,i.y,-s.y,0,-e.z,i.z,-s.z,0,0,0,0,1),this.setOrientationFromMatrix(n)}constructThreeMesh(e,i){let s=new t.BufferGeometry,n=i.length,a=new Float32Array(3*n*3),r=new Float32Array(3*n*3);for(let t=0;t<n;t++){let s=i[t];for(let i=0;i<3;i++){let n=e[s[i]];for(let e=0;e<3;++e)a[9*t+3*i+e]=n[e],r[9*t+3*i+e]=e==i?1:0}}s.setAttribute("position",new t.BufferAttribute(a,3)),s.setAttribute("barycoord",new t.BufferAttribute(r,3)),s.computeVertexNormals();let o=function(e,i,s,n){let a=`\n        ${d}\n        uniform vec3 color;\n        uniform vec3 edgeColor;\n        uniform float edgeWidth;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n\n        ${c}\n\n        void main(void){\n            float alpha = getEdgeFactor(Barycoord, vec3(1.,1.,1.), edgeWidth);\n            gl_FragColor = lightSurfaceMat((1.-alpha) * color + alpha * edgeColor, Point);\n        }\n    `,r=new t.ShaderMaterial({uniforms:{Matcap_r:{value:e},Matcap_g:{value:i},Matcap_b:{value:s},Matcap_k:{value:n},color:{value:new t.Vector3(1,0,1)},edgeColor:{value:new t.Vector3(0,0,0)},edgeWidth:{value:0}},vertexShader:"\n        attribute vec3 barycoord;\n\n        varying vec2 Point;\n        varying vec3 Barycoord;\n\n        void main()\n        {\n            vec3 vNormal = ( mat3( modelViewMatrix ) * normal );\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            Barycoord = barycoord;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:a});return r.side=t.DoubleSide,r}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);return[new t.Mesh(s,o),s]}pickElement(e){if(e<this.facePickIndStart){this.gp.setDataHeader(`Surface Mesh ${this.name}`,`Vertex ${e}`),this.gp.clearDataFields(),this.gp.showDataField("position",this.gp.prettyVector(this.coords[e]));for(let t in this.quantities){let i=this.quantities[t].getVertexValue(e);i&&this.gp.showDataField(t,i)}this.vertexPickCallback(e)}else if(e<this.edgePickIndStart){const t=e-this.facePickIndStart;this.gp.setDataHeader(`Surface Mesh ${this.name}`,`Face ${t}`),this.gp.clearDataFields(),this.facePickCallback(t)}else{const t=e-this.edgePickIndStart;this.gp.setDataHeader(`Surface Mesh ${this.name}`,`Edge ${t}`),this.gp.clearDataFields(),this.edgePickCallback(t)}}constructThreePickMesh(e,i){let s=new t.BufferGeometry,n=(e,t)=>[Math.min(e,t),Math.max(e,t)],a=i.length,r=0;this.edges=[];let o={};for(let e=0;e<a;e++){let t=i[e];for(let e=0;e<3;++e){r=Math.max(r,t[e]+1);let i=n(t[e],t[(e+1)%3]);i in o||(o[i]=this.edges.length,this.edges.push(i))}}let l=r+this.edges.length+a;this.facePickIndStart=r,this.edgePickIndStart=this.facePickIndStart+a;let h=f(this,l),d=h+r,c=d+a,u=new Float32Array(9*a),m=new Float32Array(9*a),p=new Float32Array(9*a),g=new Float32Array(9*a),v=new Float32Array(9*a),y=new Float32Array(9*a),x=new Float32Array(9*a);for(let e=0;e<a;e++){let t=i[e],s=b(e+d),a=[0,1,2].map((e=>b(h+t[e]))),r=[1,2,0].map((e=>{let i=n(t[e],t[(e+1)%3]);return b(c+o[i])}));for(let i=0;i<3;i++){t[i];for(let t=0;t<3;++t)x[9*e+3*i+t]=s[t],u[9*e+3*i+t]=a[0][t],m[9*e+3*i+t]=a[1][t],p[9*e+3*i+t]=a[2][t],g[9*e+3*i+t]=r[2][t],v[9*e+3*i+t]=r[0][t],y[9*e+3*i+t]=r[1][t]}}s.setAttribute("position",this.mesh.geometry.attributes.position),s.setAttribute("barycoord",this.mesh.geometry.attributes.barycoord),s.setAttribute("vertex_color0",new t.BufferAttribute(u,3)),s.setAttribute("vertex_color1",new t.BufferAttribute(m,3)),s.setAttribute("vertex_color2",new t.BufferAttribute(p,3)),s.setAttribute("edge_color0",new t.BufferAttribute(g,3)),s.setAttribute("edge_color1",new t.BufferAttribute(v,3)),s.setAttribute("edge_color2",new t.BufferAttribute(y,3)),s.setAttribute("face_color",new t.BufferAttribute(x,3));let C=function(){let e=new t.ShaderMaterial({vertexShader:"\n        attribute vec3 barycoord;\n        attribute vec3 color;\n        attribute vec3 vertex_color0;\n        attribute vec3 vertex_color1;\n        attribute vec3 vertex_color2;\n        attribute vec3 edge_color0;\n        attribute vec3 edge_color1;\n        attribute vec3 edge_color2;\n        attribute vec3 face_color;\n\n        varying vec3 BaryCoord;\n        varying vec3 VertexColor0;\n        varying vec3 VertexColor1;\n        varying vec3 VertexColor2;\n        varying vec3 EdgeColor0;\n        varying vec3 EdgeColor1;\n        varying vec3 EdgeColor2;\n        varying vec3 FaceColor;\n\n\n        void main()\n        {\n            BaryCoord = barycoord;\n            VertexColor0 = vertex_color0;\n            VertexColor1 = vertex_color1;\n            VertexColor2 = vertex_color2;\n            EdgeColor0 = edge_color0;\n            EdgeColor1 = edge_color1;\n            EdgeColor2 = edge_color2;\n            FaceColor = face_color;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n        }\n    ",fragmentShader:"\n        varying vec3 BaryCoord;\n        varying vec3 VertexColor0;\n        varying vec3 VertexColor1;\n        varying vec3 VertexColor2;\n        varying vec3 EdgeColor0;\n        varying vec3 EdgeColor1;\n        varying vec3 EdgeColor2;\n        varying vec3 FaceColor;\n\n        void main(void){\n\n            // Parameters defining the pick shape (in barycentric 0-1 units)\n            float vertRadius = 0.2;\n            float edgeRadius = 0.2;\n\n            vec3 shadeColor = FaceColor;\n\n            // Test vertices\n            if (BaryCoord[0] > 1.0-vertRadius) {\n                shadeColor = VertexColor0;\n            } else if(BaryCoord[1] > 1.0-vertRadius) {\n                shadeColor = VertexColor1;\n            } else if (BaryCoord[2] > 1.0-vertRadius) {\n                shadeColor = VertexColor2;\n            } else if (BaryCoord[2] < edgeRadius) {\n                shadeColor = EdgeColor0;\n            } else if (BaryCoord[0] < edgeRadius) {\n                shadeColor = EdgeColor1;\n            } else if (BaryCoord[1] < edgeRadius) {\n                shadeColor = EdgeColor2;\n            }\n\n            gl_FragColor = vec4(shadeColor, 1.);\n        }\n    "});return e.side=t.DoubleSide,e}();return new t.Mesh(s,C)}updatePositions(){}}class D{constructor(e,t,i,s={}){this.gp=i,this.nV=e.length,this.coords=e,this.name=t,this.enabled=!0,this.color=s.color||k(),this.mesh=this.constructThreeMesh(e),this.gp.doPicks&&(this.pickMesh=this.constructThreePickMesh(e)),this.quantities={},this.guiFields=void 0,this.guiFolder=void 0}addScalarQuantity(e,t){this.quantities[e]=new P(e,t,this);let i=this.guiFolder.addFolder(e);this.quantities[e].initGui(this.guiFields,i)}initGui(e,t){this.guiFields=e,this.guiFolder=t;let i=t.domElement.firstChild,s=document.createElement("li");s.classList.add("dat-info-box"),i.appendChild(s);let n=document.createElement("span");n.innerHTML="#verts: "+this.nV,s.appendChild(n),e[this.name+"#Enabled"]=!0,t.add(e,this.name+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.name+"#Color"]=this.color,this.setColor(e[this.name+"#Color"]),t.addColor(e,this.name+"#Color").onChange((e=>{this.setColor(e)})).listen().name("Color"),e[this.name+"#Radius"]=1,this.setRadius(e[this.name+"#Radius"]),t.add(e,this.name+"#Radius").min(0).max(5).step(.05).onChange((e=>{this.setRadius(e)})).listen().name("Radius"),t.open()}setColor(e){this.color=e;let i=new t.Vector3(e[0]/255,e[1]/255,e[2]/255);this.mesh.material.uniforms.color.value=i}getColor(){return this.color}setRadius(e){this.mesh.material.uniforms.scale.value=e,this.gp.doPicks&&(this.pickMesh.material.uniforms.scale.value=e)}setEnabled(e){if(this.guiFields[this.name+"#Enabled"]=e,this.enabled=e,e){let e=!1;for(let t in this.quantities)this.quantities[t].enabled&&(this.gp.scene.add(this.quantities[t].mesh),e=!0);e||this.gp.scene.add(this.mesh),this.gp.doPicks&&this.gp.pickScene.add(this.pickMesh)}else{for(let e in this.quantities)this.gp.scene.remove(this.quantities[e].mesh);this.gp.scene.remove(this.mesh),this.gp.doPicks&&this.gp.pickScene.remove(this.pickMesh)}}enableQuantity(e){if(e.isDominantQuantity)for(let t in this.quantities){let i=this.quantities[t];i.isDominantQuantity&&t!=e.name&&(this.guiFields[i.prefix+"#Enabled"]=!1,i.enabled=!1,this.gp.scene.remove(i.mesh))}this.enabled&&(e.isDominantQuantity&&this.gp.scene.remove(this.mesh),this.gp.scene.add(e.mesh))}disableQuantity(e){this.enabled&&(this.gp.scene.remove(e.mesh),this.gp.scene.add(this.mesh))}remove(){for(let e in this.quantities)this.gp.scene.remove(this.quantities[e].mesh),this.quantities[e].remove();this.quantities={}}constructThreeMesh(e){let i=new t.IcosahedronGeometry(.025,2),s=m(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k),n=new t.InstancedMesh(i,s,this.nV),a=new t.Matrix4;new Float32Array(3*this.nV);for(let t=0;t<this.nV;t++){let i=e[t];a.setPosition(i[0],i[1],i[2]),n.setMatrixAt(t,a)}return n}pickElement(e){this.gp.setDataHeader(`Point Cloud ${this.name}`,`Vertex ${e}`),this.gp.clearDataFields(),this.gp.showDataField("position",this.gp.prettyVector(this.coords[e]));for(let t in this.quantities){let i=this.quantities[t].getVertexValue(e);i&&this.gp.showDataField(t,i)}}constructThreePickMesh(e){let i=this.nV,s=new Float32Array(3*this.nV),n=f(this,i);for(let e=0;e<this.nV;e++){let t=b(e+n);for(let i=0;i<3;++i)s[3*e+ +i]=t[i]}let a=new t.ShaderMaterial({vertexShader:"\n        uniform float scale;\n        attribute vec3 color;\n\n        varying vec3 Color;\n\n\n        void main()\n        {\n            Color = color;\n\n            gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( scale * position, 1.0 );\n\n        }\n    ",fragmentShader:"\n        varying vec3 Color;\n\n        void main(void){\n            gl_FragColor = vec4(Color, 1.);\n        }\n    "}),r=new t.InstancedMesh(this.mesh.geometry.clone(),a,this.nV);return r.geometry.setAttribute("color",new t.InstancedBufferAttribute(s,3)),r.geometry.attributes.position=this.mesh.geometry.attributes.position,r.material.uniforms.scale=this.mesh.material.uniforms.scale,r.instanceMatrix=this.mesh.instanceMatrix,r}updatePositions(){}}class W{constructor(e,t,i,s,n,a={}){this.gp=n,this.res=12,this.color=a.color||k(),[this.mesh,this.tubeMesh,this.pointMesh]=this.constructThreeCurveNetwork(e,t,i),this.nV=e.length,this.segments=t,this.maxLen=i,this.name=s,this.quantities={},this.guiFields=void 0,this.guiFolder=void 0}setEnabled(e){this.guiFields[this.name+"#Enabled"]=e,e?this.gp.scene.add(this.mesh):this.gp.scene.remove(this.mesh)}remove(){for(let e in this.quantities)this.gp.scene.remove(this.quantities[e].mesh),this.quantities[e].remove();this.quantities={}}updateVertexPositions(e){const i=this.tubeMesh.geometry.attributes.len.array;let s=new t.Matrix4;for(let n=0;n<this.segments.length;n++){let a=this.gp.listToVec(e[this.segments[n][0]]),r=this.gp.listToVec(e[this.segments[n][1]]),o=new t.Vector3;o.subVectors(a,r),i[n]=o.length(),s.lookAt(new t.Vector3(0,0,0),o,new t.Vector3(0,0,1)),s.setPosition(a.x,a.y,a.z),this.tubeMesh.setMatrixAt(n,s),this.pointMesh.setMatrixAt(this.segments[n][0],s),this.pointMesh.setMatrixAt(this.segments[n][1],s)}this.tubeMesh.geometry.attributes.len.needsUpdate=!0,this.tubeMesh.instanceMatrix.needsUpdate=!0,this.pointMesh.instanceMatrix.needsUpdate=!0}setColor(e){this.color=e;let i=new t.Vector3(e[0]/255,e[1]/255,e[2]/255);this.tubeMesh.material.uniforms.color.value=i,this.pointMesh.material.uniforms.color.value=i}getColor(){return this.color}setEdgeWidth(e){this.tubeMesh.material.uniforms.rad.value=e/100,this.pointMesh.material.uniforms.scale.value=e/100}initGui(e,t){this.guiFields=e,this.guiFolder=t;let i=t.domElement.firstChild,s=document.createElement("li");s.classList.add("dat-info-box"),i.appendChild(s);let n=document.createElement("span");n.innerHTML="#verts: "+this.nV;let a=document.createElement("span");a.innerHTML="   #edges: "+this.segments.length,s.appendChild(n),s.appendChild(a),e[this.name+"#Enabled"]=!0,t.add(e,this.name+"#Enabled").onChange((e=>{this.setEnabled(e)})).listen().name("Enabled"),e[this.name+"#Color"]=this.color,this.setColor(e[this.name+"#Color"]),t.addColor(e,this.name+"#Color").onChange((e=>{this.setColor(e)})).listen().name("Color"),e[this.name+"#Width"]=1,this.setEdgeWidth(e[this.name+"#Width"]),t.add(e,this.name+"#Width").min(0).max(50).step(.25).onChange((e=>{this.setEdgeWidth(e)})).listen().name("Edge Width"),t.open()}constructThreeCurveNetwork(e,i,s){let n=new t.CylinderGeometry(1,1,1,this.res),a=new t.SphereGeometry(1,this.res,this.res),r=n.attributes.position.array,o=n.attributes.position.count;for(let e=0;e<o;e++)r[3*e+1]=r[3*e+1]- -.5;let l=new t.Matrix4;l.set(0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,1),n.applyMatrix4(l),a.applyMatrix4(l);let h=function(e,i,s,n){let a=`\n        ${d}\n        uniform vec3 color;\n\n        varying vec2 Point;\n\n        ${c}\n\n        void main(void){\n            gl_FragColor = lightSurfaceMat(color, Point);\n        }\n    `,r=new t.ShaderMaterial({uniforms:{Matcap_r:{value:e},Matcap_g:{value:i},Matcap_b:{value:s},Matcap_k:{value:n},color:{value:new t.Vector3(1,0,1)},rad:{value:1}},vertexShader:"\n        uniform float rad;\n        attribute float len;\n\n        varying vec2 Point;\n\n        void main()\n        {\n            vec3 vNormal = (modelViewMatrix * instanceMatrix * vec4(normal, 0.)).xyz;\n            vNormal = normalize(vNormal);\n\n            // pull slightly inward, to reduce sampling artifacts near edges\n            Point.x = 0.93 * vNormal.x * 0.5 + 0.5;\n            Point.y = 0.93 * vNormal.y * 0.5 + 0.5;\n\n            vec3 scaled_position = vec3(position.x * rad, position.y*rad, position.z*len);\n            gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( scaled_position, 1.0 );\n\n        }\n    ",fragmentShader:a});return r.side=t.DoubleSide,r}(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);h.uniforms.rad.value=.05;let u=m(this.gp.matcapTextures.r,this.gp.matcapTextures.g,this.gp.matcapTextures.b,this.gp.matcapTextures.k);u.uniforms.scale.value=.05;let p=new t.InstancedMesh(n,h,i.length),g=new t.InstancedMesh(a,u,e.length),v=new Float32Array(i.length);l=new t.Matrix4;for(let s=0;s<i.length;s++){let n=this.gp.listToVec(e[i[s][0]]),a=this.gp.listToVec(e[i[s][1]]),r=new t.Vector3;r.subVectors(n,a),v[s]=r.length(),l.lookAt(new t.Vector3(0,0,0),r,new t.Vector3(0,0,1)),l.setPosition(n.x,n.y,n.z),p.setMatrixAt(s,l),g.setMatrixAt(i[s][0],l),g.setMatrixAt(i[s][1],l)}p.geometry.setAttribute("len",new t.InstancedBufferAttribute(v,1));let f=new t.Group;return f.add(p),f.add(g),[f,p,g]}}o.GUI.prototype.removeFolder=function(e){var t=this.__folders[e];t&&(t.close(),this.__ul.removeChild(t.domElement.parentNode),delete this.__folders[e],this.onResize())};e.Geoptic=class{constructor(e={}){s.WEBGL.isWebGLAvailable()||alert(s.WEBGL.getWebGLErrorMessage()),this.geopticPath=e.path||"js/geoptic.js",this.parent=e.parent||document.body,this.input=void 0,this.renderer=void 0,this.scene=void 0,this.camera=void 0,this.controls=void 0,this.shiftClick=!1,this.matcapTextures=void 0,this.pickRenderer=void 0,this.pickScene=void 0,this.surfaceMeshes={},this.curveNetworks={},this.pointClouds={},this.mesh=void 0,this.geo=void 0,this.structureGui=void 0,this.structureGuiFields={},this.structureGuiMeshes=void 0,this.structureGuiCurveNetworks=void 0,this.structureGuiPointClouds=void 0,this.commandGui=new o.GUI({resizeable:!0}),this.commandGuiFields={};let i=document.createElement("div");this.parent.appendChild(i),i.id="command-gui",i.appendChild(this.commandGui.domElement),this.groundPlane=void 0,this.onMeshLoad=e=>{},this.userCallback=()=>{},this.sceneMin=new t.Vector3(0,0,0),this.sceneMax=new t.Vector3(0,0,0),this.doPicks=e.hasOwnProperty("picks")&&e.picks||!e.hasOwnProperty("picks"),this.init()}initInput(){let e=document.createElement("div");this.input=document.createElement("input"),e.appendChild(this.input),document.body.appendChild(e),this.input.id="fileInput",this.input.style.display="none",this.input.type="file"}init(){this.initInput(),this.input.addEventListener("change",function(e){document.getElementById("spinner").style.display="inline-block";let t=this.input.files[0];if(t.name.endsWith(".obj")){let e=new FileReader;e.onload=function(t){this.onMeshLoad(e.result),document.getElementById("spinner").style.display="none"}.bind(this),e.onerror=function(e){alert("Unable to load OBJ file"),document.getElementById("spinner").style.display="none"},e.readAsText(t)}else alert("Please load an OBJ file"),document.getElementById("spinner").style.display="none"}.bind(this)),this.initDOM(),this.stats=new h.default,this.stats.dom.style.position="absolute",this.container.append(this.stats.dom),this.initRenderer(this.container),this.initMatcap(),this.initGUI(),this.initCamera(),this.initScene(),this.initLights(),this.initControls(),this.initGroundPlane(),this.addEventListeners(),this.render()}initDOM(){if(this.container=document.createElement("div"),this.container.style.overflow="hidden",this.parent.appendChild(this.container),this.parent==document.body?(this.container.style.height="100vh",this.container.style.width="100vw",this.container.style.position="absolute",this.container.style.left=0,this.container.style.top=0,this.container.style["z-index"]=0,console.log(this.container)):(this.container.style.height="100%",this.container.style.position="relative"),this.doPicks){let e=document.createElement("div");e.id="selection-info";let t=document.createElement("div");t.id="info-head";let i=document.createElement("div");i.id="info-head-structure";let s=document.createElement("div");s.id="info-head-name";let n=document.createElement("div");n.id="info-body";let a=document.createElement("div");a.id="info-body-field-names";let r=document.createElement("div");r.id="info-body-field-values",n.appendChild(a),n.appendChild(r),t.appendChild(i),t.appendChild(s),e.appendChild(t),e.appendChild(n),this.container.appendChild(e)}let e=document.createElement("div");e.id="messages",this.container.appendChild(e)}initGroundPlane(){let e=(new t.TextureLoader).load(this.geopticPath+"/img/concrete.png");this.groundPlane=new n.Reflector(new t.PlaneGeometry(100,100),{clipBias:.003,textureWidth:this.container.offsetWidth*window.devicePixelRatio,textureHeight:this.container.offsetHeight*window.devicePixelRatio,color:7829367}),this.groundPlane.material.vertexShader="\n  uniform mat4 textureMatrix;\n  attribute vec2 texture_uv;\n\n  varying vec4 vUv;\n  varying vec2 TextureUV;\n\n  void main() {\n\n  \tvUv = textureMatrix * vec4( position, 1.0 );\n\n    TextureUV = texture_uv;\n\n  \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n  }\n",this.groundPlane.material.fragmentShader="\n    uniform vec3 color;\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tex;\n    uniform float alpha;\n\n    varying vec2 TextureUV;\n    varying vec4 vUv;\n\n    float blendOverlay( float base, float blend ) {\n        return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n    }\n\n    vec3 blendOverlay( vec3 base, vec3 blend ) {\n        return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n    }\n\n    float onGrid(vec2 coord2D) {\n        // Checker stripes\n        float modDist = min(min(mod(coord2D.x, 1.0), mod(coord2D.y, 1.0)), min(mod(-coord2D.x, 1.0), mod(-coord2D.y, 1.0)));\n        return 1.-smoothstep(0.005, .02, modDist);\n    }\n\n    void main() {\n\n        vec4 mat = texture2D(tex, TextureUV);\n        vec4 base = texture2DProj( tDiffuse, vUv );\n        float t = onGrid(26.*TextureUV);\n\n        gl_FragColor = (1.-t) * ((1.-alpha) * vec4( blendOverlay( base.rgb, color ), 1.0 ) + alpha * mat) + t*vec4(0.3,0.3,0.3,1.);\n\n    }\n",this.groundPlane.material.uniforms.tex={value:e},this.groundPlane.material.uniforms.alpha={value:.5},this.groundPlane.geometry.setAttribute("texture_uv",new t.BufferAttribute(Float32Array.from([0,0,0,1,1,0,1,1]),2)),this.groundPlane.rotateX(-Math.PI/2),this.scene.add(this.groundPlane)}loadMesh(e){this.onMeshLoad=e,this.input.click()}initMatcap(){this.matcapTextures={r:void 0,g:void 0,b:void 0,k:void 0},this.matcapTextures.r=(new t.TextureLoader).load(this.geopticPath+"/img/clay_r.png"),this.matcapTextures.g=(new t.TextureLoader).load(this.geopticPath+"/img/clay_g.png"),this.matcapTextures.b=(new t.TextureLoader).load(this.geopticPath+"/img/clay_b.png"),this.matcapTextures.k=(new t.TextureLoader).load(this.geopticPath+"/img/clay_k.png")}initRenderer(e){this.renderer=new t.WebGLRenderer({antialias:!0}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setClearColor(16777215,1),this.renderer.setSize(this.container.offsetWidth,this.container.offsetHeight),this.container.appendChild(this.renderer.domElement),this.doPicks&&(this.pickRenderer=new t.WebGLRenderer({antialias:!1}),this.pickRenderer.setPixelRatio(window.devicePixelRatio),this.pickRenderer.setClearColor(16777215,1),this.pickRenderer.setSize(this.container.offsetWidth,this.container.offsetHeight),e.appendChild(this.pickRenderer.domElement))}initGUI(){this.structureGui=new o.GUI({autoPlace:!1,resizeable:!0});let e=document.createElement("div");this.parent.appendChild(e),e.id="structure-gui",e.appendChild(this.structureGui.domElement),this.geopticOptions=this.structureGui.addFolder("Geoptic"),this.geopticOptions.open(),this.structureGuiFields["GroundPlane#Enabled"]=!0,this.geopticOptions.add(this.structureGuiFields,"GroundPlane#Enabled").onChange((e=>{e?this.scene.add(this.groundPlane):this.scene.remove(this.groundPlane)})).listen().name("Ground Plane")}initCamera(){const e=this.container.offsetWidth/this.container.offsetHeight;this.camera=new t.PerspectiveCamera(45,e,.01,1e3),this.camera.position.z=3.5}initScene(){this.scene=new t.Scene,this.scene.background=new t.Color(16777215),this.doPicks&&(this.pickScene=new t.Scene,this.pickScene.background=new t.Color(16777215))}initLights(){let e=new t.AmbientLight(16777215,.35);this.camera.add(e);let i=new t.PointLight(16777215);i.position.set(2,20,15),this.camera.add(i),this.scene.add(this.camera)}registerSurfaceMesh(e,i,s,n=1){i=G(i),s=A(s),this.structureGuiMeshes||(this.structureGuiMeshes=this.structureGui.addFolder("Surface Meshes"),this.structureGuiMeshes.open());const a={};this.surfaceMeshes[e]&&(a.color=this.surfaceMeshes[e].getColor(),this.deregisterSurfaceMesh(e));let r=new B(i,s,e,this,a);this.surfaceMeshes[e]=r;let o=this.structureGuiMeshes.addFolder(e);r.initGui(this.structureGuiFields,o),this.scene.add(r.mesh),this.doPicks&&this.pickScene.add(r.pickMesh);let l=(new t.Box3).setFromObject(r.mesh);this.sceneMin.min(l.min),this.sceneMax.max(l.max);let h=this.groundPlane.position;return this.groundPlane.translateZ(this.sceneMin.y-h.y,1),r}registerCurveNetwork(e,t,i){if(t=G(t),this.structureGuiCurveNetworks||(this.structureGuiCurveNetworks=this.structureGui.addFolder("Curve Networks"),this.structureGuiCurveNetworks.open()),i)i=A(i);else{i=[];for(let e=0;e+1<t.length;e++)i.push([e,e+1])}let s=t.length;const n={};this.curveNetworks[e]&&(n.color=this.curveNetworks[e].getColor(),this.deregisterCurveNetwork(e));let a=new W(t,i,s,e,this,n);this.curveNetworks[e]=a;let r=this.structureGuiCurveNetworks.addFolder(e);return a.initGui(this.structureGuiFields,r),this.scene.add(a.mesh),a}registerPointCloud(e,t){t=G(t),this.structureGuiPointClouds||(this.structureGuiPointClouds=this.structureGui.addFolder("Point Clouds"),this.structureGuiPointClouds.open());const i={};this.pointClouds[e]&&(i.color=this.pointClouds[e].getColor(),this.deregisterPointCloud(e));let s=new D(t,e,this,i);this.pointClouds[e]=s;let n=this.structureGuiPointClouds.addFolder(e);return s.initGui(this.structureGuiFields,n),this.scene.add(s.mesh),this.doPicks&&this.pickScene.add(s.pickMesh),s}deregisterSurfaceMesh(e){e in this.surfaceMeshes&&(this.structureGuiMeshes.removeFolder(e),this.surfaceMeshes[e].remove(),this.scene.remove(this.surfaceMeshes[e].mesh),delete this.surfaceMeshes[e])}deregisterCurveNetwork(e){e in this.curveNetworks&&(this.structureGuiCurveNetworks.removeFolder(e),this.curveNetworks[e].remove(),this.scene.remove(this.curveNetworks[e].mesh),delete this.curveNetworks[e])}deregisterPointCloud(e){e in this.pointClouds&&(this.structureGuiPointClouds.removeFolder(e),this.pointClouds[e].remove(),this.scene.remove(this.pointClouds[e].mesh),delete this.pointClouds[e])}clearAllStructures(){let e=Object.keys(this.surfaceMeshes);e.forEach((e=>{this.deregisterSurfaceMesh(e)})),e=Object.keys(this.curveNetworks),e.forEach((e=>{this.deregisterCurveNetwork(e)}))}initControls(){this.controls=new i.TrackballControls(this.camera,this.renderer.domElement),this.controls.rotateSpeed=5}clearDataFields(){document.getElementById("info-body-field-names").innerHTML="",document.getElementById("info-body-field-values").innerHTML=""}showDataField(e,t){let i=document.createElement("div");i.innerHTML=e,document.getElementById("info-body-field-names").appendChild(i);let s=document.createElement("div");s.innerHTML=t,document.getElementById("info-body-field-values").appendChild(s)}setDataHeader(e,t){document.getElementById("info-head-structure").innerHTML=e,document.getElementById("info-head-name").innerHTML=t}pick(e,t){const i=this.parent.getBoundingClientRect(),s=y(this.pickRenderer,this.pickScene,this.camera,e-i.left,t-i.top,i.width,i.height);s.structure&&s.structure.pickElement(s.localInd)}addEventListeners(){window.addEventListener("resize",this.onWindowResize.bind(this),!1),this.doPicks&&this.renderer.domElement.addEventListener("click",this.onMouseClick.bind(this),!1)}onWindowResize(){this.camera.aspect=this.container.offsetWidth/this.container.offsetHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(this.container.offsetWidth,this.container.offsetHeight),this.controls.handleResize(),this.render()}onMouseClick(e){e.clientX>=0&&e.clientX<=this.container.offsetWidth&&e.clientY>=0&&e.clientY<=this.container.offsetHeight&&this.pick(e.clientX,e.clientY)}animate(){requestAnimationFrame(function(){this.animate()}.bind(this)),this.userCallback(),this.controls&&this.controls.update(),this.render(),this.stats.update()}render(){let e=this.container.offsetWidth;this.renderer.setViewport(0,0,e,this.container.offsetHeight),this.renderer.setScissor(0,0,e,this.container.offsetHeight),this.renderer.setScissorTest(!0),this.renderer.render(this.scene,this.camera)}message(e){let t=document.getElementById("messages"),i=document.createElement("div");t.insertBefore(i,t.firstChild),i.innerHTML=e}startLoading(){console.log("start loading!"),document.getElementById("spinner").style.display="inline-block"}doneLoading(){document.getElementById("spinner").style.display="none"}slowFunction(e){this.startLoading(),setTimeout(function(){e(),this.doneLoading()}.bind(this),1)}prettyScalar(e){return e.toFixed(5)}prettyVector2(e){return e.x?"("+e.x.toFixed(2)+", "+e.y.toFixed(2)+")":"("+e[0].toFixed(2)+", "+e[1].toFixed(2)+")"}prettyVector(e){return e.x?"("+e.x.toFixed(2)+", "+e.y.toFixed(2)+", "+e.z.toFixed(2)+")":"("+e[0].toFixed(2)+", "+e[1].toFixed(2)+", "+e[2].toFixed(2)+")"}listToVec(e){return new t.Vector3(e[0],e[1],e[2])}},Object.defineProperty(e,"__esModule",{value:!0})}));
